# interview-study
interview study materials 101


## Interview exposed book

1 - before the search

find what kind of programmer your are(what do you like to do)

application dev

short-term projects


Visit two kinds of job sites as part of your research. Job listing sites such as Dice (which specializes in technology-related career listings), Indeed, and Monster (general job listing sites) enable you to see what kinds of jobs are currently in demand. Review sites such as Glassdoor discuss working conditions, salaries, bonuses, perks, and other informa- tion useful for finding the right kind of company for you.

No contracts and no offshore


Another way to make yourself more difficult to replace is to acquire domain specific knowledge: expertise related to the programs you write but outside of the field of programming. For example, if you develop financial software, it’s much more difficult to out- source your job if it involves the application of accounting skills in addition to programming than if you’re purely a coder.

develop marketable skills

* participating in programming contests
* proffeesional development courses - coursera, etc
* master or doctorate degree
* don't bother with certifications
* work on side project , or open source development
* Use code contest sites. TopCoder, HackerRank, CodeWars, and several similar sites have developers “face-off” to solve programming problems. If you win, meaning you solve the problem faster than the competitor or bot, you move up the leaderboards and get a higher rank, which you can make public and list on your résumé.

Companies look for software developers who get things done. You may look great on paper in terms of skills and education, but credentials and knowledge don’t make products or services that a company can sell. It’s your ability to accomplish something that truly sets you apart from the other candidates.

Your online profile—everything public about you online—is just as important as your résumé. Recruiters use online profiles to find desirable candidates

* Google search results for your name. This is the first impression you make on potential employers and colleagues.
* LinkedIn profile. LinkedIn is a social network for tracking professional connections. It’s free to join, and you can create a detailed profile about yourself, including your jobs and your education—essentially an online résumé. Colleagues and customers can publicly endorse you or your work, which can be quite valuable.
* GitHub profile. Many employers will evaluate your work through your GitHub profile well before they meet you. Take a look and spend a few hours to clean up your GitHub profile so it reflects your best code. Delete or change the privacy settings for incomplete, poorly orga- nized, or low-quality repositories. Assume your profile may be checked even before you’re asked about it. If you don’t have very much public, move your best code to public so it’s clear that you have significant code and experience with GitHub.
* Stack Overflow. This will show up on your Google search result, or may be checked. If you have recent, basic questions that reflect poorly on your knowledge, you may want to delete them. If you don’t have a profile, you should make one, especially if your job search is still a few months out and you have time to answer other people’s questions.
* Angel investor sites. These sites don’t just connect investors with startups, they also connect startups with potential hires. AngelList is the big player in this category. Create a profile that reflects your interests and expertise.
* Other social network profiles. Other social networks such as Facebook, Twitter, or Snapchat may be reviewed, depending on your privacy settings. Make sure you clean up and tighten your profile so nothing unprofessional appears public.
* Personal website. This is a potential source of more in-depth information about you and top- ics you find interesting. If you blog about political or controversial topics, you may want to remove such posts during your job search.
* Articles and blog posts. If you write about programming-related topics, this is a good way for recruiters to assess your experience.
* Comments and forum posts. These provide another way to gain some insight into your pro- gramming skills and your general attitude toward technology and technology companies.


WARNING One caveat about updating your LinkedIn profile: by default, all your contacts are notified of your updates. Many people have learned to inter- pret these notifications as de facto announcements that someone is looking for a new job. That might help you get the word out, but if your contacts include people at your current company and you don’t want them to know you’re look- ing for a new job, disable these notifications before you make your updates.

What you do before a formal job search is critical to finding the right kind of job. With that in mind, you should consider the following things:

* Know your likes and dislikes as a programmer and a prospective employee.
* Understand the market to find and apply for the best jobs.
* Develop the marketable skills that employers look for and that can enhance your career.
* Manage your public profile to show you in the best possible light and make sure there are no surprises to turn off potential employers.


## 2 - the job application process


Interviewing and recruiting procedures are similar at most tech companies, so the more pre- pared you are for what you will encounter, the more successful you will be. This chapter familiarizes you with the entire job-search process, from contacting companies to starting your new job, so you won’t need to write off your first few application attempts as learning experiences.

FINDING AND CONTACTING COMPANIES

The first step to getting a job is to find and make contact with companies you’re interested in working for. Although referrals are the best way to land a job, you can also work with head- hunters or contact a company directly.


* decide the companies that you are going to apply
* add the all known people in facebook or linked in who working that company that you want to work
* top coder, hackerrank and codewars.
* applied in the offitial page -> headhunter or referrals


After you’ve been given a specific offer that includes details about salary, signing bonus, benefits, and possibly stock options, you need to decide whether you’re satisfied with it. This shouldn’t be a snap decision—never accept an offer on the spot. Always spend at least a day thinking about impor- tant decisions such as this; it’s surprising how much can change in a day.


Negotiating Your Salary

If, after careful consideration, the offer meets or exceeds your expectations, you’re all set. On the other hand, if you’re not completely happy with your offer, you should try to negotiate. Most people ask for too little, as opposed to too much. Don’t be afraid to “lean in,” no matter who you are or

what your background is. All too often, applicants assume that offers are nonnegotiable and reject them without negotiation or accept offers they’re not pleased with. Almost every offer is negotiable to some extent.


You can find prospective jobs in various ways, but networking through friends and acquaintances is usually the best method. If that’s not possible, find and contact companies directly. You may also engage the services of a headhunter; be aware that the headhunter’s motivations aren’t always aligned with yours.
The interviews are the most important part of the job application process. You will have one or two screening interviews, usually by phone, to ensure that you’re applying for the right job and that you are actually qualified. After the screening interviews, you’ll usually go through a series of on-site technical interviews that ultimately determine whether a job offer comes your way. Be sure to dress appropriately for the interviews, and turn off any electronic gadgets you might have with you.
During the interview process you’ll frequently interact with one of the company’s recruiters, espe- cially if a job offer is made. Be sure to understand the recruiter’s role during this process.
When an offer is made, don’t accept it immediately. Give yourself time to consider it. Look over the offer, and try to negotiate a better deal because most offers aren’t fixed in stone, no matter what the recruiter says. After accepting a job offer, be sure to contact anyone else who has made you an offer to thank them for their interest in you.

phone screen interview(1st interview)

Knowledge-based questions are common during on-site interviews as well as phone screens -> from you resume one or two

some basic coding and design tasks.


Instead, many of these problems require algorithmic tricks or uncommonly used features of a language.

The problems often prohibit you from using the most common way to do something or from using the ideal data structure. For example, you might be given a problem such as: “Write a function that determines whether two integers are equal without using any comparison operators.”

Interactivity Is Key
The code you write in the interview is probably the only example of your code that your interviewer sees. If you write ugly code, your interviewer will assume you always write ugly code. This is your chance to shine and show your best code. Take the time to make your code solid and pretty.


What the interviewer wants is to see your thought processes as you work through each stage of the programming problem.

The problem-solving process in these interviews is interactive, and if you have difficulty, the inter- viewer generally guides you to the correct answer via a series of hints. Of course, the less help you need to solve the problem, the better you look, but showing an intelligent thought process and responding well to the hints you are given is also important. 

 Break down the answer into discrete steps and explain the thought processes behind each step.
 
 Keep talking! Always explain what you are doing. Otherwise, the inter- viewer has no way of knowing how you tackle complex programming problems.
 
When you begin solving a problem, don’t start writing code immediately. First, make sure you com- pletely understand the problem. It may help to work through a simple, concrete example and then try to generalize the process to an algorithm. When you’re convinced you have the right algorithm, explain it clearly. Writing the code should be one of your final steps.
 

1 - Make sure you understand the problem. Your initial assumptions about the problem may be wrong, or the interviewer’s explanation may be brief or difficult to follow. You can’t demon- strate your skills if you don’t understand the problem. Don’t hesitate to ask your interviewer questions, and don’t start solving the problem until you understand it. The interviewer may be deliberately obscuring things to determine whether you can find and understand the actual problem. In these cases, asking the right clarifying questions is an important part of the cor- rect solution.

2 - When you understand the question, try a simple example. This example may lead to insights about how to solve the general problem or bring to light any remaining misunderstandings that you have. Starting with an example also demonstrates a methodical, logical thought process. Examples are especially useful if you don’t see the solution right away.

3 - Focus on the algorithm and data structures you will use to solve the problem. This can take a long time and require additional examples. This is to be expected. Interactivity is important during this process. If you stand quietly staring at the whiteboard, the interviewer has no way of knowing whether you’re making productive headway or are simply clueless. Talk to your interviewer about what you are doing. For example, you might say something like, “I’m wondering whether I can store the values in an array and then sort them, but I don’t think that will work because I can’t quickly look up elements in an array by value.” This demon- strates your skill, which is the point of the interview, and may also lead to hints from the interviewer, who might respond, “You’re close to the solution. Do you really need to look up elements by value, or could you....”

It may take a long time to solve the problem, and you may be tempted to begin coding before you figure out a complete solution. Resist this temptation. Consider who you would rather work with: someone who thinks about a problem for a long time and then codes it correctly the first time or someone who hastily jumps into a problem, makes several errors while cod- ing, and doesn’t have any idea what direction to take. Not a difficult decision, is it?

4 - After you figure out your algorithm and how you can implement it, explain your solution
to the interviewer. This provides an opportunity to evaluate your solution before you begin coding. Your interviewer may say, “Sounds great, go ahead and code it,” or something
like, “That’s not quite right because you can’t look up elements in a hash table that way.” Another common response is “That sounds like it will work, but there’s a more efficient solu- tion.” In any case, you gain valuable information about whether you should move on to cod- ing or go back to working on the algorithm.

5 - While you code, explain what you’re doing. For example, you might say, “Here, I’m initial- izing the array to all zeros.” This narrative enables the interviewer to follow your code more easily.


6- Ask questions when necessary. You generally won’t be penalized for asking factual questions that you might otherwise look up in a reference. You obviously can’t ask a question such
as, “How do I solve this problem?” but it is acceptable to ask a question such as, “I can’t remember—what format string do I use to print out a localized date?” Although it’s better to know these things, it’s okay to ask this sort of question.

7- After you write the code for a problem, immediately verify that the code works by tracing through it with an example. This step demonstrates clearly that your code is correct in at least one case. It also illustrates a logical thought process and your intention to check your work and search for bugs. The example may also help you flush out minor bugs in your solution.

8- Make sure you check your code for all error and special cases, especially boundary condi- tions. Programmers often overlook error and special cases; forgetting these cases in an interview indicates you might forget them on the job. If time does not allow for extensive checking, at least explain that you should check for such failures. Covering error and special cases can impress your interviewer and help you correctly solve the problem.

After you try an example and feel comfortable that your code is correct, the interviewer may ask you questions about what you wrote. These questions often focus on running time, alternative implementations, and complexity (discussed later in this chapter). If your interviewer does not ask you these questions, you should volunteer the information to show that you are cognizant of these issues. For example, you could say, “This implementation has linear running time, which is the best achievable running time since I need to check all the input values. The dynamic memory allocation will slow it down a little, as will the overhead of using recursion.”

When You Get Stuck

Getting stuck on a problem is expected and an important part of the interviewing process. Interviewers want to see how you respond when you don’t recognize the answer to a question imme- diately. Giving up or getting frustrated is the worst thing to do if this happens to you. Instead, show interest in the problem and keep trying different ways to solve it:

* Go back to an example. Try performing the task and analyzing what you are doing. Try extending your specific example to the general case. You may have to use detailed examples. This is okay, because it shows the interviewer your persistence in finding the correct solution.

* Try a different data structure. Perhaps a linked list, an array, a hash table, or a binary search tree can help. If you’re given an unusual data structure, look for similarities between it and more familiar data structures. Using the right data structure often makes a problem much easier.

* Consider the less commonly used or more advanced aspects of a language. Sometimes the key to a problem involves one of these features.


Even when you don’t feel stuck, you may not be converging on the optimal solution. You may miss an elegant or nonobvious way to implement something. Pause every once in a while to reconsider the bigger picture and whether there may be a better approach. One sign that you may be off track is if you find yourself writing too much code. Almost all interview coding questions have short answers. You rarely need to write more than 30 lines of code and almost never more than 50. If you start writing a lot of code, you may be heading in the wrong direction.

### ANALYZING YOUR SOLUTION

After you answer the problem, you may be asked about the efficiency of your implementation. Often, you have to compare trade-offs between your implementation and another possible solution and identify the conditions that make each option more favorable. Common questions focus on run time and memory usage.

A good understanding of Big-O analysis is critical to making a good impression with the inter- viewer. Big-O analysis is a form of runtime analysis that measures the efficiency of an algorithm in terms of the time it takes for the algorithm to run as a function of the input size. It’s not a formal benchmark, just a simple way to classify algorithms by relative efficiency when dealing with very large input sizes.
Most coding problem solutions in this book include a runtime analysis to help you solidify your understanding of the algorithms.


Best, Average, and Worst Cases
You may think this comparison was stacked against CompareToAll because the maximum value was at the end. This is true, and it raises the important issues of best-case, average-case, and worst-case running times. The analysis of CompareToAll was a worst-case scenario: the maximum value was at the end of the array. Consider the average case, in which the largest value is in the middle. You end up checking only half the values n times because the maximum value is in the middle. This results
in checking n(n/2) = n2/2 times. This would appear to be an O(n2/2) running time. However, Big-O analysis is concerned with the way the running time changes as the input becomes very large. As n increases toward infinity, the difference between n2/2 and n2 become negligible relative to the differ- ence between n2 and any other functional form (e.g., n or n3). Therefore, in Big-O analysis, you drop all constant factors, just as you drop all lower order terms. This is why you can consider the time
for every operation to be equivalent: considering different constant time requirements for different operations would yield a constant multiplicative factor, which you would drop anyway. With this in mind, the average case for CompareToAll is no better than the worst case. It is still O(n2).

The best-case running time for CompareToAll is better than O(n2). In this case, the maximum value is at the beginning of the array. The maximum value is compared to all other values only once, so the result is an O(n) running time.

In CompareToMax, the best-case, average-case, and worst-case running times are identical. Regardless of the arrangement of the values in the array, the algorithm is always O(n).

Ask interviewers which scenario they’re most interested in. Sometimes you’ll find clues to this in the problem. Some sorting algorithms with terrible worst cases for unsorted data may nonetheless be well suited for a problem if the input is already sorted. These kinds of trade-offs are discussed in

The fastest possible running time for any runtime analysis is O(1), commonly referred to as con- stant running time. An algorithm with constant running time always takes the same amount of time to execute, regardless of the input size. This is the ideal run time for an algorithm, but it’s rarely achievable.

* O(log n). An algorithm is said to be logarithmic if its running time increases logarithmically in proportion to the input size.
log 10 = 1

* O(n). A linear algorithm’s running time increases in direct proportion to the input size.
10 = 10

* O(n log n). A quasilinear algorithm is midway between a linear algorithm and a polynomial
algorithm.
10 log 10 = 10 

* O(n^c). A polynomial algorithm grows quickly based on the size of the input.
10^2 = 100

* O(c^n). An exponential algorithm grows even faster than a polynomial algorithm.
2^10= 1,024

* O(n!). A factorial algorithm grows the fastest and becomes quickly unusable for even small
values of n.
10! = 3,628,800

Memory Footprint Analysis

Runtime analysis is not the only relevant metric for performance. A common request from inter- viewers is to analyze how much memory a program uses. This is sometimes referred to as the memory footprint of the application. Memory use is sometimes as important as running time, par- ticularly in constrained environments such as embedded systems.

In some cases, you will be asked about the memory usage of an algorithm. For this, the approach is to express the amount of memory required in terms of n, the size of the input, analogous to the preceding discussion of Big-O runtime analysis. The difference is that instead of determining how many operations are required for each item of input, you determine the amount of storage required for each item


Other times, you may be asked about the memory footprint of an implementation. This is usually an exercise in estimation, especially for languages such as Java and C# that run in a virtual machine. Interviewers don’t expect you to know to-the-byte exactly how much memory is used, but they like to see that you understand how the underlying data structures might be implemented.

SUMMARY

How you solve programming problems during your interviews can determine whether you get a job offer, so you need to answer them as correctly and completely as you can. The problems usually get progressively harder as the day progresses, so don’t be surprised if you need an occasional hint from the interviewer. You normally code in a mainstream programming language, but the choice of lan- guage is ultimately dictated by the requirements of the job for which you apply, so be familiar with the right languages.

Interact with your interviewers as much as possible as you attempt each problem. Let them know what you’re thinking at each point in your analysis of the problem and your attempts at coding an answer. Start by making sure you understand the problem, and then try some examples to reinforce that understanding. Choose the algorithm and make sure it works for those examples. Remember to test for special cases. If you’re stuck, try more examples or choose a different algorithm. Keep obscure or advanced language features in mind when looking for alternative answers.

If asked to comment on the performance of a solution, a Big-O runtime analysis is usually sufficient. Algorithms that run in constant, logarithmic, linear, or quasilinear time are preferred. You should also be prepared to comment on the memory footprint of an algorithm.


## Google Resume book

Passion. Creativity. Initiative. Intelligence. And a “getting things done” attitude. 

You need to be able to answer questions about your prior work with illustrative examples. You need to understand the company so that you can tell your interviewer why you want to work there and what you’ll add. And, finally, you need to be able to ask interesting questions to your interviewer that demonstrate your research and interest. 

Practice Your Pitch

* For each job or position, practice stating a short blurb explaining what your role was and what you accomplished. Practice two blurbs: one that would be understandable from those in your field, and one that’s understandable for nonspecialists. Stay light on the details and let the interview probe as necessary.

* Pay special attention to the pitches for your most recent role, as they’re the most relevant. You could even consider recording this pitch and playing it back to yourself—do you mumble during cer- tain parts? Friends can also be useful here. Where do they think you are weakest and strongest? 
behavior interview

prepare preparation grid.

put keyword

points :  challenging, what ou learned, influencing someone, conflict and mistake

![image](https://user-images.githubusercontent.com/25869911/163633510-c1c5eb97-0739-4ba2-a38b-007fbb26f7f4.png)

review your resume : 

The day before your interview, pick up your résumé and explain each bullet out loud, just as you would if your interviewer asks, “What did you mean by this line?” Make sure you can explain the “what, how, and why.” 


Do Your Homework

Recruiting is expensive, and companies want to know that you’re excited about the job. They hate having a candidate reject their offer almost as much as candidates hate getting rejected. Moreover, enthusiastic candidates are more likely to work hard at a job and stay at the company. Companies look for enthusiasm, and researching the company, position, and people is one way to prove that.


#### the programming interview

15 minutes - discussion, which usually includes some questions about your résumé and/or offers you a chance to ask the interviewer questions.
45 minutes - main coding interview

Google - bit manipulation and scalability like desing a web crawler

amazon - OO design questions, scalability questions .

microsoft - emphasize testing and design skills more in developers than other companies do

apple - Make sure you understand Apple’s products, especially those of the team you are interviewing with.  What would you improve about the product? Remember that Apple has a lot of smart people who haven’t yet done what you’re suggesting. Think about why they haven’t.

quality matters more than quantity 

* try to solve the problem on your own.
* write the code for the algorithm on paper
* test your code - manual
* type your code into a computer exactly as is - rerun what you written 
* start a list of all the mistakes you made, and analyze what types of mistakes you make the most ofter


Data structures

* Linked Lists, binary trees, tries, stacks, queues, vectors/arraylists, hash tables

Algorithms

* BFS, DFS, binary search, merge sort, quick sort, tree insert/find/etc

concepts

* bit manipulation, singleton desing pattern, factory design pattern, memory(stack vs heap), recursion, Big-o TIme

For each of the topics, make sure you understand how to implement/use them, and (where applicable) the space and time complexity.

We must often make a trade-off between time and space, and sometimes, we do sacrifice time efficiency to reduce memory usage.



1. Ask your interviewer questions to resolve ambiguity. 

* What are the data types? How much data is there? What assumptions do you need to solve the problem? Who is the user?

2. Design an algorithm. make example and see the pattern or general solution.

* What are the space and time complexities?
* What happens if there is a lot of data?
* Does your design cause other issues? (i.e., if you’re creating
a modified version of a binary search tree, did your design
impact the time for insert/find/delete?)
* If there are other issues, did you make the right trade-offs?
* If they gave you specific data (e.g., mentioned that the data is ages, or in sorted order), have you leveraged that informa- tion? There’s probably a reason that you’re given it.


3. Write pseudo-code first, but make sure to tell your interviewer that you’re writing pseudo-code! Otherwise, he/she may think that you’re never planning to write “real” code, and many interviewers will hold that against you.

* Writing pseudo-code first can help you outline your thoughts clearly and reduce the number of mistakes you commit.

4. Write your code, not too slow and not too fast.

* Use data structures generously. Where relevant, use a good data structure or define your own. For example, if you’re asked a problem involving finding the minimum age for a group of people, consider defining a data structure to represent a Person. This shows your interviewer that you care about good object-oriented design.

5. Test your code and carefully fix any mistakes.  -> normal test case and edge cases

* Extreme cases: 0, negative, null, maximums, etc.
* User error: What happens if the user passes in null or a nega-
tive value?
* General cases: Test the normal case.

6. tell big o of time and space

Algorithm Questions: Five Ways to Create an Algorithm

Keep in mind that the more problems you practice, the easier it will be to identify which approach to use.

Also, remember that the five approaches can be “mixed and matched.” That is, once you’ve applied “Simplify and Generalize,” you may want to implement Pattern Matching next.

Approach 1: Examplify

* Examplify simply means to write out specific examples of the problem and see if you can figure out a general rule.

Approach 2: Pattern Matching

Pattern matching means to relate a problem to similar ones, and figure out if you can modify the solution to solve the new problem. This is one reason why practicing lots of problems is important; the more problems you do, the better you get.

Approach 3: Simplify and Generalize

In Simplify and Generalize, we change constraints (data type, size, etc.) to simplify the problem, and then try to solve the simplified problem. Once you have an algorithm for the “simplified” problem, you can generalize the problem back to its original form

Approach 4: Base Case and Build

Base Case and Build suggests that we solve the algorithm first for a base case (e.g., just one element). Then, try to solve it for elements one and two, assuming that you have the answer for element one. Then, try to solve it for elements one, two, and three, assuming that you have the answer to elements one and two.


Approach 5: Data Structure Brainstorm

The Data Structure Brainstorm approach admittedly feels somewhat hacky, but it often works. In this approach, we simply run through a list of data structures and try to apply each one. This approach works because many algorithms are quite straightforward once we find the right data structure.

Object-oriented design (OOD) questions come in two flavors: OOD for a piece of software and OOD for a real-world object 

* What are your goals? Imagine, for example, you are asked to design the classes for a generic deck of cards. What kind of cards? Are they standard playing cards, UNO cards, or some other kind? Just how “generic” is it supposed to be? 
* What are the core objects? For example, if you’re doing the OOD for a restaurant, your core objects might be Restaurant, Patron, Party, Host, Server, Busser, Table, and so on. Each of these will become a class. 
* How do the objects relate to each other? There is probably only one Restaurant, so this can be a singleton class. Restaurant has many Servers, one Host, many Bussers, many Tables, many Parties, and many Patrons. (Note: This is just an assumption; talk to your interviewer about this). Each Table has one Server and one Party. Look for and remove redundancies. For example, Restaurant may not need a list of Patrons, since it can get that from the list of Parties. 
* How do the objects interact? Think about what the major actions that occur in the restaurant are. For example, a Party makes a Reservation with a Host. The Host sits the Party at a Table and assigns them a Server. Each of these actions should generally correspond to one or more meth- ods. By walking through these methods, you may discover that you missed some objects or that your design isn’t quite right. That’s OK—now is a great time to add them! 
* Are there any tricky algorithms? In some cases, there may be an algorithm that impacts the design. For example, implementing findNextReservation(int partySize) might require some changes to how the reservations are refer- enced. Discuss these details with your interviewer. 


Remember that object-oriented design questions require a lot of communication with your interviewer about how flexible your design should be and how to balance certain trade-offs. There is no “right” answer to an object-oriented design question.


Scalability Questions

When I interviewed at Google, I didn’t know a thing about large systems. Sure, I’d taken a distributed computing course where we studied election algorithms and whatnot, but that had nothing to do with what I was asked. Sort a million numbers? Design a web crawler? Yikes!

I fumbled my way through the problem, and I realized I could do this just fine. Once I forgot that I had no idea what I was doing, I learned that I actually understood the primary com- plexities of large amounts of data and dealing with multiple systems at once.
 
 All I needed to do was take things step by step. Imagine, for instance, that we’re designing a hypothetical system X for millions of items (users, files, etc.):
 
1. How would you solve the problem for a small number of items? Develop an algorithm for this case, which is often pretty straightforward.

2. What happens when you try to implement that algorithm with millions of items? It’s likely that you have run out of space on the computer. So, divide up the files across many computers.

* How do you divide up data across many machines? That is, do the first 100 items appear on the same computer? Or all items with the same hash value mod 100?
* About how many computers will you need? To esti- mate this, ask how big each item is, and take a guess at (or ask your interviewer) how much space a typical computer has.
 
 3. Now, fix the problems that occur when you are using many computers. Make sure to answer the following questions:

* How does one machine know which machine it should
access to look up data?
* Can data get out of sync across computers? How do you
handle that?
* How can you minimize expensive reads across computers?


testing interviews

True testing questions usually fall into one of three categories:

1. How would you test this real-world object?

steps:
* ask questions to understand what the object is
* Who is using it, and what are they doing with it?
* What are the unexpected uses?
* Are there additional stress cases?
* Can you fail gracefully?
* What are the test cases?


2. Explain how you would test this piece of computer software.

steps:
* Ask questions to resolve ambiguity.
* Who is the user?
* What is the feature set?
* Are there unexpected uses or stress cases?
* When there are failures, what can you do to fail gracefully?
* What can be automated, and what must be manu- ally tested?

3. Test a method (possibly one that you just wrote).

steps:
* As always, ask questions to resolve ambiguity
* What do you need to test for? 
* Write the expected cases.
* Write the extreme cases. 


## Grokking the coding interview

In many problems dealing with an array (or a LinkedList), we are asked to find or calculate something among all the subarrays (or sublists) of a given size. For example, take a look at this problem:

### Pattern: Sliding Window

#### Given an array, find the average of all subarrays of ‘K’ contiguous elements in it.

* Array: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5
 
Here, we are asked to find the average of all subarrays of ‘5’ contiguous elements in the given array. Let’s solve this:

* For the first 5 numbers (subarray from index 0-4), the average is: (1+3+2+6-1)/5 => 2.2
(1+3+2+6−1)/5=>2.2
* The average of next 5 numbers (subarray from index 1-5) is: (3+2+6-1+4)/5 => 2.8
(3+2+6−1+4)/5=>2.8
* For the next 5 numbers (subarray from index 2-6), the average is: (2+6-1+4+1)/5 => 2.4
(2+6−1+4+1)/5=>2.4

Here is the final output containing the averages of all subarrays of size 5:

* Output: [2.2, 2.8, 2.4, 3.6, 2.8]

A brute-force algorithm will calculate the sum of every 5-element subarray of the given array and divide the sum by ‘5’ to find the average. This is what the algorithm will look like:

```java
import java.util.Arrays;

public class AverageOfSubarrayOfSizeK  {
    
    
    public static double[] findAverages(int k, int[] arr) {
        double[] result = new double[arr.length-k+1];
        
        for(int i =0; i <= arr.length - k; i++) {
            // find sum of next K elements
            double sum = 0;
            for(int j = i; j < i+k; j++) {
                sum+= arr[j];
            }
            result[i] = sum/k; // calculate average
        }
        
        return result;
        
    }
    
    public static void main(String args[]) {
        double[] result = AverageOfSubarrayOfSizeK.findAverages(5, new int[] {1,3,26,-1,4,1,8,2});
        System.out.println("Average of subarrays of size k: " + Arrays.toString(result));
    }
}
```
Time complexity: Since for every element of the input array, we are calculating the sum of its next ‘K’ elements, the time complexity of the above algorithm will be O(N*K) where ‘N’ is the number of elements in the input array.

input * K element -> 9 * 5 = 45

The inefficiency is that for any two consecutive subarrays of size ‘5’, the overlapping part (which will contain four elements) will be evaluated twice. For example, take the above-mentioned input:

![image](https://user-images.githubusercontent.com/25869911/163731416-c83364b1-c231-46fa-9c4d-1d281671621c.png)

As you can see, there are four overlapping elements between the subarray (indexed from 0-4) and the subarray (indexed from 1-5). Can we somehow reuse the sum we have calculated for the overlapping elements?

The efficient way to solve this problem would be to visualize each subarray as a sliding window of ‘5’ elements. This means that we will slide the window by one element when we move on to the next subarray. To reuse the sum from the previous subarray, we will subtract the element going out of the window and add the element now being included in the sliding window. This will save us from going through the whole subarray to find the sum and, as a result, the algorithm complexity will reduce to O(N).   

big(O)= 9

```java
import java.util.*;

public class AverageOfSubarrayOfSizeK {
    
    private static double[] getAverage(int K, int[] array) { 
        double[] result = new double[array.length-K+1]; //9-5+1 = 5
        
        double windSum = 0;
        int windStart = 0;
        
        for(int windEnd=0; windEnd < array.length; windEnd++) {  // 0 to 8 (size of 9)
            
            windSum += array[windEnd];
            
            if(windEnd >= K-1) { //5
                result[windStart] = windSum/K; // get the average
                windSum -= array[windStart]; // substract the lement going out
                windStart++; // slide the window ahead
            }
            
        }
        
        return result;
        
    }
    
    public static void main(String[] args) {
        int[] input = new int[]{1, 3, 2, 6, -1, 4, 1, 8, 2};
        double[] output = AverageOfSubarrayOfSizeK.getAverage(5,input);
        System.out.println("average of subarray of size k: "+ Arrays.toString(output));
        
    }
} 
```

#### Maximum Sum Subarray of Size K (easy)

Problem Statement

* Given an array of positive numbers and a positive number ‘k,’ find the maximum sum of any contiguous subarray of size ‘k’.

Example 1:

```terminal
Input: [2, 1, 5, 1, 3, 2], k=3 
Output: 9
Explanation: Subarray with maximum sum is [5, 1, 3].
```
Example 2:

```terminal
Input: [2, 3, 4, 1, 5], k=2 
Output: 7
Explanation: Subarray with maximum sum is [3, 4].
```

Solution

A basic brute force solution will be to calculate the sum of all ‘k’ sized subarrays of the given array to find the subarray with the highest sum. We can start from every index of the given array and add the next ‘k’ elements to find the subarray’s sum. Following is the visual representation of this algorithm for Example-1:

![image](https://user-images.githubusercontent.com/25869911/163733398-e3a9ed9c-d865-4ec8-a0e5-69d424268feb.png)

brute force solution

```java
public static int findMaxSumSubArray(int k, int[] arr) {
   int maxSum = 0, windowSum;
   for (int i = 0; i <= arr.length - k; i++) {
     windowSum = 0;
     for (int j = i; j < i + k; j++) {
       windowSum += arr[j];
     }
     maxSum = Math.max(maxSum, windowSum);
   }

   return maxSum;
 }

 public static void main(String[] args) {
   System.out.println("Maximum sum of a subarray of size K: "
       + MaxSumSubArrayOfSizeK.findMaxSumSubArray(3, new int[] { 2, 1, 5, 1, 3, 2 }));
   System.out.println("Maximum sum of a subarray of size K: "
       + MaxSumSubArrayOfSizeK.findMaxSumSubArray(2, new int[] { 2, 3, 4, 1, 5 }));
 }
 ```
 The above algorithm’s time complexity will be O(N*K), where ‘N’ is the total number of elements in the given array.
 
If you observe closely, you will realize that to calculate the sum of a contiguous subarray, we can utilize the sum of the previous subarray. For this, consider each subarray as a Sliding Window of size ‘k.’ To calculate the sum of the next subarray, we need to slide the window ahead by one element. So to slide the window forward and calculate the sum of the new position of the sliding window, we need to do two things:

* Subtract the element going out of the sliding window, i.e., subtract the first element of the window.
* Add the new element getting included in the sliding window, i.e., the element coming right after the end of the window.

Solution
```java
class MaxSumSubArrayOfSizeK {
  public static int findMaxSumSubArray(int k, int[] arr) {
    int max = 0;
    int sum = 0;
    int result[] = new int[arr.length-k+1]; //4
    int sumWindow = 0;
    int startWindow = 0;

    for(int endWindow = 0; endWindow < arr.length; endWindow++) {
      sum += arr[endWindow];

      if(endWindow >= k-1) {
        max = Math.max(max,sum) // max = (max < sum) ? sum: max;
        sum -= arr[startWindow]; 
        startWindow++;
      }
    }

    return max;
  }
}
```



Time Complexity

The time complexity of the above algorithm will be O(N)

Space Complexity

The algorithm runs in constant space O(1)

#### Smallest Subarray With a Greater Sum (easy)


Given an array of positive numbers and a positive number ‘S,’ find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’. Return 0 if no such subarray exists.

Example 1:

```terminal
Input: [2, 1, 5, 2, 3, 2], S=7
Output: 2
Explanation: The smallest subarray with a sum greater than or equal to ‘7’ is [5, 2].
```
Example 2:
```terminal
Input: [2, 1, 5, 2, 8], S=7
Output: 1
Explanation: The smallest subarray with a sum greater than or equal to ‘7’ is [8].
```
```terminal
Example 3:

Input: [3, 4, 1, 1, 6], S=8
Output: 3
Explanation: Smallest subarrays with a sum greater than or equal to ‘8’ are [3, 4, 1] or [1, 1, 6].
```

Solution

This problem follows the Sliding Window pattern, and we can use a similar strategy as discussed in Maximum Sum Subarray of Size K. There is one difference though: in this problem, the sliding window size is not fixed. Here is how we will solve this problem:

* First, we will add-up elements from the beginning of the array until their sum becomes greater than or equal to ‘S.’
* These elements will constitute our sliding window. We are asked to find the smallest such window having a sum greater than or equal to ‘S.’ We will remember the length of this window as the smallest window so far.
* After this, we will keep adding one element in the sliding window (i.e., slide the window ahead) in a stepwise fashion.
* In each step, we will also try to shrink the window from the beginning. We will shrink the window until the window’s sum is smaller than ‘S’ again. This is needed as we intend to find the smallest window. This shrinking will also happen in multiple steps; in each step, we will do two things:
  * Check if the current window length is the smallest so far, and if so, remember its length.
  * Subtract the first element of the window from the running sum to shrink the sliding window.

Here is the visual representation of this algorithm for the Example-1:

![image](https://user-images.githubusercontent.com/25869911/163734481-cc908024-9024-405c-ada0-e71e3935e56a.png)

![image](https://user-images.githubusercontent.com/25869911/163734489-a15e091e-2205-4ec7-83ed-03d62d82bfd3.png)

```java
public static int findMinSubArray(int S, int[] arr) {
   int windowSum = 0, minLength = Integer.MAX_VALUE;
   int windowStart = 0;
   for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {
     windowSum += arr[windowEnd]; // add the next element
     // shrink the window as small as possible until the 'windowSum' is smaller than 'S'
     while (windowSum >= S) {
       minLength = Math.min(minLength, windowEnd - windowStart + 1);
       windowSum -= arr[windowStart]; // subtract the element going out
       windowStart++; // slide the window ahead
     }
   }

   return minLength == Integer.MAX_VALUE ? 0 : minLength;
 }
```
Time Complexity

The time complexity of the above algorithm will be O(N). The outer for loop runs for all elements, and the inner while loop processes each element only once; therefore, the time complexity of the algorithm will be O(N+N), which is asymptotically equivalent to O(N)


Space Complexity

The algorithm runs in constant space O(1)

### Pattern: Two Pointers

In problems where we deal with sorted arrays (or LinkedLists) and need to find a set of elements that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem:


* Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.

To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where ‘N’ is the number of elements in the input array.

Given that the input array is sorted, an efficient way would be to start with one pointer in the beginning and another pointer at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do not, we will do one of two things:

* If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.

* If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.

![image](https://user-images.githubusercontent.com/25869911/164612377-3b0aa808-341b-475b-81eb-8aaf6b0e217f.png)

The time complexity of the above algorithm will be O(N)

In the following chapters, we will apply the Two Pointers approach to solve a few problems.


#### Pair with Target Sum (easy)

Problem Statement

Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.

Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.

Example 1:
```terminal
Input: [1, 2, 3, 4, 6], target=6
Output: [1, 3]
Explanation: The numbers at index 1 and 3 add up to 6: 2+4=6
Example 2:
```
```terminal
Input: [2, 5, 9, 11], target=11
Output: [0, 2]
Explanation: The numbers at index 0 and 2 add up to 11: 2+9=11
```

##### Solution brute force

To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where ‘N’ is the number of elements in the input array.

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {
    // TODO: Write your code here
    int[] result = new int[2];
    for(int i=0; i < arr.length; i++) {
      for(int j=i+1; j < arr.length; j++) {
        if(arr[i]+arr[j] == targetSum) {
          result[0] = i;
          result[1] = j;
        }
      }
    }
    return result;
  }
}
```

##### Solution two pointers

Since the given array is sorted, a brute-force solution could be to iterate through the array, taking one number at a time and searching for the second number through Binary Search. The time complexity of this algorithm will be O(N*logN). Can we do better than this?

We can follow the Two Pointers approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair; otherwise, we will do one of two things:

* If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.
* If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.

![image](https://user-images.githubusercontent.com/25869911/164617047-9a815b96-a397-40d8-beab-9ec920f79e08.png)

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {
    
    // left and right pointer
    int leftPointer = 0, rightPointer = arr.length-1;
    
    while(leftPointer < rightPointer) {
      int currentSum = arr[leftPointer]+arr[rightPointer];
      // found the pair 
      if(currentSum == targetSum) {
        return new int[]{leftPointer, rightPointer}; 
      }

      if(currentSum < targetSum) {
        leftPointer++;
      } else {
        rightPointer--;
      }
    }
    
    return new int[] {-1,-1};
  }
}
```
Time Complexity
The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array.

Space Complexity

The algorithm runs in constant space O(1)

##### An Alternate approach

Instead of using a two-pointer or a binary search approach, we can utilize a HashTable to search for the required pair. We can iterate through the array one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ such that “X + Y == Target”. We will do two things here:

* Search for ‘Y’ (which is equivalent to “Target - X”) in the HashTable. If it is there, we have found the required pair.
* Otherwise, insert “X” in the HashTable, so that we can search it for the later numbers.

Here is what our algorithm will look like:

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {

    HashMap<Integer, Integer> numbers = new HashMap<Integer,Integer>();

    for(int i = 0; i < arr.length; i++) {
      if(numbers.containsKey(targetSum-arr[i])) {
        return new int[] { numbers.get(targetSum-arr[i]), i };
      } else {
        numbers.put(arr[i], i);
      }
    }

    return new int[]{-1,-1};
  
  }
}
```

Time Complexity
The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array.

Space Complexity
The space complexity will also be O(N), as, in the worst case, we will be pushing ‘N’ numbers in the HashTable.

* Solutions :

worst = iterate all element with 2 fors time complexity(n^2)->quadratic and space complexity(1)
average = iterate n first element and second element use binary search (n * log n) and space complexity(1)
improved = hash table time (n) but also space is (n)
best = two pointers time(n)-> lineal but space is (1) ->constant


### Pattern: Fast & Slow pointers

The Fast & Slow pointer approach, also known as the Hare & Tortoise algorithm, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic(circulary) LinkedLists or arrays.

By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop.

One of the famous problems solved using this technique was Finding a cycle in a LinkedList. Let’s jump onto this problem to understand the Fast & Slow pattern.

#### LinkedList Cycle (easy)

Problem Statement

Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

![image](https://user-images.githubusercontent.com/25869911/164634074-3b64cf3a-2af3-49e6-85e1-dfcece0a23ad.png)

* Solution

Imagine two racers running in a circular racing track. If one racer is faster than the other, the faster racer is bound to catch up and cross the slower racer from behind. We can use this fact to devise an algorithm to determine if a LinkedList has a cycle in it or not.

Imagine we have a slow and a fast pointer to traverse the LinkedList. In each iteration, the slow pointer moves one step and the fast pointer moves two steps. This gives us two conclusions:

* If the LinkedList doesn’t have a cycle in it, the fast pointer will reach the end of the LinkedList before the slow pointer to reveal that there is no cycle in the LinkedList.
* The slow pointer will never be able to catch up to the fast pointer if there is no cycle in the LinkedList.

If the LinkedList has a cycle, the fast pointer enters the cycle first, followed by the slow pointer. After this, both pointers will keep moving in the cycle infinitely. If at any stage both of these pointers meet, we can conclude that the LinkedList has a cycle in it. Let’s analyze if it is possible for the two pointers to meet. When the fast pointer is approaching the slow pointer from behind we have two possibilities:

* The fast pointer is one step behind the slow pointer.
* The fast pointer is two steps behind the slow pointer.

All other distances between the fast and slow pointers will reduce to one of these two possibilities. Let’s analyze these scenarios, considering the fast pointer always moves first:

* If the fast pointer is one step behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step, and they both meet.
* If the fast pointer is two steps behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step. After the moves, the fast pointer will be one step behind the slow pointer, which reduces this scenario to the first scenario. This means that the two pointers will meet in the next iteration.

This concludes that the two pointers will definitely meet if the LinkedList has a cycle. A similar analysis can be done where the slow pointer moves first. Here is a visual representation of the above discussion:

![image](https://user-images.githubusercontent.com/25869911/164648164-3097975e-f573-46f5-bd52-ce59214559dc.png)

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/141-linked-list-cycle

 ```java
 class ListNode {
  int value = 0;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class LinkedListCycle {

  public static boolean hasCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
      if(fast == slow) return true;
    }
    return false;
  }

  public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    head.next.next.next.next.next = new ListNode(6);
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));

    head.next.next.next.next.next.next = head.next.next;
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));

    head.next.next.next.next.next.next = head.next.next.next;
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));
  }
}
```

Time Complexity

As we have concluded above, once the slow pointer enters the cycle, the fast pointer will meet the slow pointer in the same loop. Therefore, the time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList.

Space Complexity

The algorithm runs in constant space O(1)

#### Similar Problems

* Problem 1: Given the head of a LinkedList with a cycle, find the length of the cycle.

* Solution: We can use the above solution to find the cycle in the LinkedList. Once the fast and slow pointers meet, we can save the slow pointer and iterate the whole cycle with another pointer until we see the slow pointer again to find the length of the cycle.

Here is what our algorithm will look like:

```java
class ListNode {
  int value = 0;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class LinkedListCycleLength {

  public static int findCycleLength(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
      if (slow == fast) // found the cycle
        return calculateLength(slow);
    }
    return 0;
  }

  private static int calculateLength(ListNode slow) {
    ListNode current = slow;
    int cycleLength = 0;
    do {
      current = current.next;
      cycleLength++;
    } while (current != slow);
    return cycleLength;
  }

  public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    head.next.next.next.next.next = new ListNode(6);
    head.next.next.next.next.next.next = head.next.next;
    System.out.println("LinkedList cycle length: " + LinkedListCycleLength.findCycleLength(head));

    head.next.next.next.next.next.next = head.next.next.next;
    System.out.println("LinkedList cycle length: " + LinkedListCycleLength.findCycleLength(head));
  }
}
```


Time and Space Complexity: The above algorithm runs in O(N) time complexity and O(1) space complexity.

### Pattern: Merge Intervals

This pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap.

Given two intervals (‘a’ and ‘b’), there will be six different ways the two intervals can relate to each other:

![image](https://user-images.githubusercontent.com/25869911/164877773-47e52ca4-06e1-4c4f-bb1c-dc3923a9c5da.png)

Understanding the above six cases will help us in solving all intervals related problems. Let’s jump onto our first problem to understand the Merge Interval pattern.

#### Merge Intervals (medium)

Problem Statement 

Given a list of intervals, merge all the overlapping intervals to produce a list that has only mutually exclusive intervals.

Example 1:

```terminal
Intervals: [[1,4], [2,5], [7,9]]
Output: [[1,5], [7,9]]
Explanation: Since the first two intervals [1,4] and [2,5] overlap, we merged them into 
one [1,5].
```

![image](https://user-images.githubusercontent.com/25869911/164877871-df1298bf-71a0-4de3-85ab-06d54b940446.png)

Example 2:

```terminal
Intervals: [[6,7], [2,4], [5,9]]
Output: [[2,4], [5,9]]
Explanation: Since the intervals [6,7] and [5,9] overlap, we merged them into one [5,9].
```

Example 3:
```terminal
Intervals: [[1,4], [2,6], [3,5]]
Output: [[1,6]]
Explanation: Since all the given intervals overlap, we merged them into one.
```

Solution 

Let’s take the example of two intervals (‘a’ and ‘b’) such that a.start <= b.start. There are four possible scenarios:

![image](https://user-images.githubusercontent.com/25869911/164878371-80238214-41cf-42d9-8da7-67e9eca2d40a.png)

Our goal is to merge the intervals whenever they overlap. For the above-mentioned three overlapping scenarios (2, 3, and 4), this is how we will merge them:

![image](https://user-images.githubusercontent.com/25869911/164878402-f4ff5553-6bf8-46f8-bbac-d0afc961adcf.png)

The diagram above clearly shows a merging approach. Our algorithm will look like this:

* Sort the intervals on the start time to ensure a.start <= b.start
* If ‘a’ overlaps ‘b’ (i.e. b.start <= a.end), we need to merge them into a new interval ‘c’ such that:

```terminal
c.start = a.start
c.end = max(a.end, b.end)
```
* We will keep repeating the above two steps to merge ‘c’ with the next interval if it overlaps with ‘c’.

```java
import java.util.*;

class Interval {
  int start;
  int end;

  public Interval(int start, int end) {
    this.start = start;
    this.end = end;
  }
};

class MergeIntervals {

  public static List<Interval> merge(List<Interval> intervals) {
    // check first the input, when there is one element, return that element, dont need comparations
    if(intervals.size() < 2) return intervals;

    // we need to sort by start time first, to do some traverse the List -> n log n
    Collections.sort(intervals, (a,b) -> Integer.compare(a.start, b.start));

    // create the mergedIntervals list,Interator to iterate and get the first value of interval in the list
    List<Interval> mergedIntervals = new LinkedList<Interval>();
    Iterator<Interval> intervalItr = intervals.iterator();
    Interval interval = intervalItr.next(); // get the first element, minumun list size = 2
    int start = interval.start;
    int end = interval.end;

    // we need to traver the list and find the overlapping or not overlapping
    while(intervalItr.hasNext()) {
      interval = intervalItr.next(); // the next element
      if(interval.start <= end) { // overlapping, we need to merge updating only the max value of the ends
        end = Math.max(end, interval.end);
      } else { // no overlapping, add the values to mergedIntervals, we need to update to the next interval
        mergedIntervals.add(new Interval(start,end));
        start = interval.start;
        end = interval.end;
      }
    }

    // but in the case where there is no overlapping we need to add the last interval values
    mergedIntervals.add(new Interval(start,end));

    return mergedIntervals;
  }

  public static void main(String[] args) {
    List<Interval> input = new ArrayList<Interval>();
    input.add(new Interval(1, 4));
    input.add(new Interval(2, 5));
    input.add(new Interval(7, 9));
    System.out.print("Merged intervals: ");
    for (Interval interval : MergeIntervals.merge(input))
      System.out.print("[" + interval.start + "," + interval.end + "] ");
    System.out.println();

    input = new ArrayList<Interval>();
    input.add(new Interval(6, 7));
    input.add(new Interval(2, 4));
    input.add(new Interval(5, 9));
    System.out.print("Merged intervals: ");
    for (Interval interval : MergeIntervals.merge(input))
      System.out.print("[" + interval.start + "," + interval.end + "] ");
    System.out.println();

    input = new ArrayList<Interval>();
    input.add(new Interval(1, 4));
    input.add(new Interval(2, 6));
    input.add(new Interval(3, 5));
    System.out.print("Merged intervals: ");
    for (Interval interval : MergeIntervals.merge(input))
      System.out.print("[" + interval.start + "," + interval.end + "] ");
    System.out.println();
  }
}
```

Time complexity

The time complexity of the above algorithm is O(N * logN), where ‘N’ is the total number of intervals. We are iterating the intervals only once which will take O(N)
O(N), in the beginning though, since we need to sort the intervals, our algorithm will take O(N * logN)


Space complexity
The space complexity of the above algorithm will be O(N) as we need to return a list containing all the merged intervals. We will also need O(N) space for sorting. For Java, depending on its version, Collections.sort() either uses Merge sort or Timsort, and both these algorithms need O(N) space. Overall, our algorithm has a space complexity of O(N).

Similar Problems

Problem 1: Given a set of intervals, find out if any two intervals overlap.

Example:
```terminal
Intervals: [[1,4], [2,5], [7,9]]
Output: true
Explanation: Intervals [1,4] and [2,5] overlap
```

Solution: We can follow the same approach as discussed above to find if any two intervals overlap.

### Pattern: Cyclic Sort

This pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range. For example, take the following problem:

* You are given an unsorted array containing n numbers taken from the range 1 to n. The array can have duplicates, which means that some numbers will be missing. Find all the missing numbers.

To efficiently solve this problem, we can use the fact that the input array contains numbers in the range of 1 to n. For example, to efficiently sort the array, we can try placing each number at its correct place, i.e., placing 1 at index '0', placing 2 at index ‘1’, and so on. Once we are done with the sorting, we can iterate the array to find all indices missing the correct numbers. These will be our required numbers.

Let’s jump on to our first problem to understand the Cyclic Sort pattern in detail.

#### Cyclic Sort(easy)

Problem Statement

We are given an array containing n objects. Each object, when created, was assigned a unique number from the range 1 to n based on their creation sequence. This means that the object with sequence number 3 was created just before the object with sequence number 4.

Write a function to sort the objects in-place on their creation sequence number in O(n) and without using any extra space. For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.
 
 Example 1:
```terminal
Input: [3, 1, 5, 4, 2]
Output: [1, 2, 3, 4, 5]
```

Example 2:
```terminal
Input: [2, 6, 4, 3, 1, 5]
Output: [1, 2, 3, 4, 5, 6]
```

Example 3:
```terminal
Input: [1, 5, 6, 4, 3, 2]
Output: [1, 2, 3, 4, 5, 6]
```

Solution

As we know, the input array contains numbers from the range 1 to n. We can use this fact to devise an efficient way to sort the numbers. Since all numbers are unique, we can try placing each number at its correct place, i.e., placing 1 at index ‘0’, placing 2 at index ‘1’, and so on.

To place a number (or an object in general) at its correct index, we first need to find that number. If we first find a number and then place it at its correct place, it will take us O(N^2), which is not acceptable.

Instead, what if we iterate the array one number at a time, and if the current number we are iterating is not at the correct index, we swap it with the number at its correct index. This way, we will go through all numbers and place them at their correct indices, hence, sorting the whole array.

Let’s see this visually with the above-mentioned Example-2:

![image](https://user-images.githubusercontent.com/25869911/164882978-f66c0bb8-2128-4873-8fd8-5c7c491f1687.png)

![image](https://user-images.githubusercontent.com/25869911/164882990-a501d153-471f-4a0a-aa7f-81fbd89a501c.png)

```java
class CyclicSort {

  public static void sort(int[] nums) {
    int pos = 0;
    while( pos < nums.length) {
      int orderedPos = nums[pos] -1;
      if(nums[pos] != nums[orderedPos]) {
        swap(nums, pos, orderedPos);
      } else { // is ordered 
        pos++;
      }
    }
  }

  private static void swap(int[] nums, int pos, int orderedPos) {
    int temp = nums[pos];
    nums[pos] = nums[orderedPos];
    nums[orderedPos] = temp;
  }

}
```

Time complexity

The time complexity of the above algorithm is O(n). Although we are not incrementing the index i when swapping the numbers, this will result in more than n iterations of the loop, but in the worst-case scenario, the while loop will swap a total of n-1 numbers, and once a number is at its correct index, we will move on to the next number by incrementing i. So overall, our algorithm will take O(n) + O(n-1) which is asymptotically equivalent to O(n)


Space complexity

The algorithm runs in constant space O(1)


### Pattern: In-place Reversal of a LinkedList

In a lot of problems, we are asked to reverse the links between a set of nodes of a LinkedList. Often, the constraint is that we need to do this in-place, i.e., using the existing node objects and without using extra memory.

In-place Reversal of a LinkedList pattern describes an efficient way to solve the above problem. In the following chapters, we will solve a bunch of problems using this pattern.

Let’s jump on to our first problem to understand this pattern.

#### Reverse a LinkedList (easy)

Problem Statement

Given the head of a Singly LinkedList, reverse the LinkedList. Write a function to return the new head of the reversed LinkedList.

Solution

To reverse a LinkedList, we need to reverse one node at a time. We will start with a variable current which will initially point to the head of the LinkedList and a variable previous which will point to the previous node that we have processed; initially previous will point to null.

In a stepwise manner, we will reverse the current node by pointing it to the previous before moving on to the next node. Also, we will update the previous to always point to the previous node that we have processed. Here is the visual representation of our algorithm:

![image](https://user-images.githubusercontent.com/25869911/164883876-277d4b91-8bf3-440b-a048-795d2eee48a2.png)

![image](https://user-images.githubusercontent.com/25869911/164883900-3513c50b-2408-4c2c-b4c0-b3534372aa56.png)

![image](https://user-images.githubusercontent.com/25869911/164883906-bee6f16a-c194-48d9-86b0-0ded8d36a905.png)

![image](https://user-images.githubusercontent.com/25869911/164883914-7795b9dd-2a85-4b1c-8c1e-fc6ea0b625da.png)

![image](https://user-images.githubusercontent.com/25869911/164883923-b98961af-6c0c-4274-b989-b8fb9e1728f2.png)

![image](https://user-images.githubusercontent.com/25869911/164883935-c42e4d48-4dbc-4066-8a09-33cca4fb7f43.png)

![image](https://user-images.githubusercontent.com/25869911/164883970-f8272612-785a-45ff-8d53-b50794a01c6c.png)

```java
class ListNode {
  int value = 0;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class ReverseLinkedList {

  public static ListNode reverse(ListNode head) {
    ListNode current = head;
    ListNode previous = null;
    ListNode next = null;

    while(current != null) {
      next = current.next; // store temporary next node in next
      current.next = previous; // change the node direction to the previous
      previous = current; // previous node is current node
      current = next; // current node is next node
    }

    // we need to return previous, because in the end previous will be new head
    return previous;

  }

  public static void main(String[] args) {
    ListNode head = new ListNode(2);
    head.next = new ListNode(4);
    head.next.next = new ListNode(6);
    head.next.next.next = new ListNode(8);
    head.next.next.next.next = new ListNode(10);

    ListNode result = ReverseLinkedList.reverse(head);
    System.out.print("Nodes of the reversed LinkedList are: ");
    while (result != null) {
      System.out.print(result.value + " ");
      result = result.next;
    }
  }
}
```
https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/206-reverse-linked-list

Time complexity

The time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList.

Space complexity

We only used constant space, therefore, the space complexity of our algorithm is O(1)


### Pattern: Tree Breadth First Search

This pattern is based on the Breadth First Search (BFS) technique to traverse a tree.

Any problem involving the traversal of a tree in a level-by-level order can be efficiently solved using this approach. We will use a Queue to keep track of all the nodes of a level before we jump onto the next level. This also means that the space complexity of the algorithm will be O(W), where ‘W’ is the maximum number of nodes on any level.

Let’s jump onto our first problem to understand this pattern.

#### Binary Tree Level Order Traversal (easy)

Problem Statement

Given a binary tree, populate an array to represent its level-by-level traversal. You should populate the values of all nodes of each level from left to right in separate sub-arrays.

Example 1:

![image](https://user-images.githubusercontent.com/25869911/164943709-8bb2cf4e-9313-4e98-b2f6-e4391b6b8bee.png)

Example 2:

![image](https://user-images.githubusercontent.com/25869911/164943747-7ff1c268-9ced-415f-b5a4-c8d881c88f63.png)


Solution

Since we need to traverse all nodes of each level before moving onto the next level, we can use the Breadth First Search (BFS) technique to solve this problem.

We can use a Queue to efficiently traverse in BFS fashion. Here are the steps of our algorithm:

* Start by pushing the root node to the queue.
* Keep iterating until the queue is empty.
* In each iteration, first count the elements in the queue (let’s call it levelSize). We will have these many nodes in the current level.
* Next, remove levelSize nodes from the queue and push their value in an array to represent the current level.
* After removing each node from the queue, insert both of its children into the queue.
* If the queue is not empty, repeat from step 3 for the next level.

Let’s take the example-2 mentioned above to visually represent our algorithm:

![image](https://user-images.githubusercontent.com/25869911/164944045-80d51f4d-3059-445f-a83e-c82a596b31fe.png)

![image](https://user-images.githubusercontent.com/25869911/164944074-10f45413-5dd6-4d31-9f97-6f207a4546b1.png)

![image](https://user-images.githubusercontent.com/25869911/164944081-a8ec3013-daf4-434b-a56e-b9ceeb662f68.png)

![image](https://user-images.githubusercontent.com/25869911/164944120-ce139680-984a-4592-ba67-59ed2b413403.png)

![image](https://user-images.githubusercontent.com/25869911/164944143-70336f39-4985-4f8d-81a9-854d98617ba6.png)

![image](https://user-images.githubusercontent.com/25869911/164944148-a8b05076-59b2-4187-a137-0f2b1b65d5ca.png)

![image](https://user-images.githubusercontent.com/25869911/164944155-88fd6d98-a0be-41c1-8c34-2fda69054281.png)


```java
import java.util.*;

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
};

class LevelOrderTraversal {
  public static List<List<Integer>> traverse(TreeNode root) {
    // create the  list of list result and return the result
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    
    // check the input validation, if root is null return empty result
    if(root == null) return result;

    // create temprary queue to store the level nodes
    Queue<TreeNode> queue = new LinkedList<TreeNode>();

    // insert the root to the queue 
    queue.offer(root);

    // create the condition to traverse the tree
    while(!queue.isEmpty()) {
      // get the size of the queue
      int levelSize = queue.size();
      // create the levelNodes to store each level nodes
      List<Integer> levelNodes = new ArrayList<Integer>(levelSize);

      // traeverse the queue
      for(int i = 0; i < levelSize; i++) {
        // get the currentNode from queue
        TreeNode currentNode = queue.poll();
        // add the currentNode value to the levelNodes
        levelNodes.add(currentNode.val);
        // check the (child)left and right node of current node, if exist add to the queue
        if(currentNode.left != null) queue.offer(currentNode.left);
        if(currentNode.right != null) queue.offer(currentNode.right);
      }

      // add the levelNodes to the result
      result.add(levelNodes);
    }
    
    return result;
    
  }

  public static void main(String[] args) {
    TreeNode root = new TreeNode(12);
    root.left = new TreeNode(7);
    root.right = new TreeNode(1);
    root.left.left = new TreeNode(9);
    root.right.left = new TreeNode(10);
    root.right.right = new TreeNode(5);
    List<List<Integer>> result = LevelOrderTraversal.traverse(root);
    System.out.println("Level order traversal: " + result);
  }
}
```
https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/102-binary-tree-level-order-traversal

Time complexity

The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.

Space complexity

The space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue.

### Pattern: Tree Depth First Search

This pattern is based on the Depth First Search (DFS) technique to traverse a tree.

We will be using recursion (or we can also use a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing. This also means that the space complexity of the algorithm will be O(H), where ‘H’ is the maximum height of the tree.

Let’s jump onto our first problem to understand this pattern.

#### Binary Tree Path Sum (easy)

Problem Statement

Given a binary tree and a number ‘S’, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals ‘S’.

![image](https://user-images.githubusercontent.com/25869911/164945610-9486df1c-be58-44fb-b0c3-1446b2c3d47b.png)


Solution

As we are trying to search for a root-to-leaf path, we can use the Depth First Search (DFS) technique to solve this problem.

To recursively traverse a binary tree in a DFS fashion, we can start from the root and at every step, make two recursive calls one for the left and one for the right child.

Here are the steps for our Binary Tree Path Sum problem:

* Start DFS with the root of the tree.
* If the current node is not a leaf node, do two things:
  * Subtract the value of the current node from the given number to get a new sum => S = S - node.value
  * Make two recursive calls for both the children of the current node with the new number calculated in the previous step.
* At every step, see if the current node being visited is a leaf node and if its value is equal to the given number ‘S’. If both these conditions are true, we have found the required root-to-leaf path, therefore return true.
* If the current node is a leaf but its value is not equal to the given number ‘S’, return false.

Let’s take the example-2 mentioned above to visually see our algorithm:

![image](https://user-images.githubusercontent.com/25869911/164945761-f0689db7-04a1-40c0-ae77-681023a9ed3b.png)

![image](https://user-images.githubusercontent.com/25869911/164945768-f574597a-9858-4433-bdc0-a27def9b0d22.png)

![image](https://user-images.githubusercontent.com/25869911/164945770-4b776f78-caad-4d9a-accd-5c5b0fb908bf.png)

![image](https://user-images.githubusercontent.com/25869911/164945780-29ba2371-3d6d-435f-a53c-9d78e15d79f5.png)

![image](https://user-images.githubusercontent.com/25869911/164945784-7c720b0a-a840-4c28-8d3b-01fb3d621fd9.png)

![image](https://user-images.githubusercontent.com/25869911/164945787-f08cf3ce-677a-46fe-9eca-2879529f7b4f.png)

![image](https://user-images.githubusercontent.com/25869911/164945790-d8117b2c-9c2b-4b03-9396-049bced9b8b4.png)

![image](https://user-images.githubusercontent.com/25869911/164945794-6adc63da-b3bd-425d-8361-173cb92b08ee.png)

![image](https://user-images.githubusercontent.com/25869911/164945798-f496e243-b7cd-4967-9f39-e1e884cd46fe.png)

![image](https://user-images.githubusercontent.com/25869911/164945803-204d8ad2-b798-4a29-b61a-f69e4519e102.png)


```java

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
};

class TreePathSum {
  public static boolean hasPath(TreeNode root, int sum) {
    //dfs is recursive algorithm
    // check the input first
    if(root == null) return false;

    //condition to end the recursive call, the current node is leaf(no chidls -> left or right node)
    // and the sum is equal to currentNode value
    if(root.left == null && root.right == null && root.val == sum) return true;

    // recursive call to child nodes
    // we need to rest the current value
    return hasPath(root.left, sum-root.val) || hasPath(root.right, sum-root.val);

  }

  public static void main(String[] args) {
    TreeNode root = new TreeNode(12);
    root.left = new TreeNode(7);
    root.right = new TreeNode(1);
    root.left.left = new TreeNode(9);
    root.right.left = new TreeNode(10);
    root.right.right = new TreeNode(5);
    System.out.println("Tree has path: " + TreePathSum.hasPath(root, 23));
    System.out.println("Tree has path: " + TreePathSum.hasPath(root, 16));
  }
}

```

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/112-path-sum

Time complexity
The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.

Space complexity

The space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).

### Pattern: Two Heaps

In many problems, where we are given a set of elements such that we can divide them into two parts. We are interested in knowing the smallest element in one part and the biggest element in the other part. The Two Heaps pattern is an efficient approach to solve such problems.

As the name suggests, this pattern uses two Heaps; A Min Heap to find the smallest element and a Max Heap to find the biggest element.

Let’s jump onto our first problem to see this pattern in action.

#### Find the Median of a Number Stream (medium)

Problem Statement

Design a class to calculate the median of a number stream. The class should have the following two methods:

* insertNum(int num): stores the number in the class
* findMedian(): returns the median of all numbers inserted in the class

If the count of numbers inserted in the class is even, the median will be the average of the middle two numbers.

Example 1:

```terminal
1. insertNum(3)
2. insertNum(1)
3. findMedian() -> output: 2
4. insertNum(5)
5. findMedian() -> output: 3
6. insertNum(4)
7. findMedian() -> output: 3.5
```

Solution

As we know, the median is the middle value in an ordered integer list. So a brute force solution could be to maintain a sorted list of all numbers inserted in the class so that we can efficiently return the median whenever required. Inserting a number in a sorted list will take O(N) time if there are ‘N’ numbers in the list. This insertion will be similar to the Insertion sort. Can we do better than this? Can we utilize the fact that we don’t need the fully sorted list - we are only interested in finding the middle element ?

Assume ‘x’ is the median of a list. This means that half of the numbers in the list will be smaller than (or equal to) ‘x’ and half will be greater than (or equal to) ‘x’. This leads us to an approach where we can divide the list into two halves: one half to store all the smaller numbers (let’s call it smallNumList) and one half to store the larger numbers (let’s call it largeNumList). The median of all the numbers will either be the largest number in the smallNumList or the smallest number in the largeNumList. If the total number of elements is even, the median will be the average of these two numbers.

The best data structure that comes to mind to find the smallest or largest number among a list of numbers is a Heap. Let’s see how we can use a heap to find a better algorithm.

* We can store the first half of numbers (i.e., smallNumList) in a Max Heap. We should use a Max Heap as we are interested in knowing the largest number in the first half.
* We can store the second half of numbers (i.e., largeNumList) in a Min Heap, as we are interested in knowing the smallest number in the second half.
* Inserting a number in a heap will take O(logN), which is better than the brute force approach.
* At any time, the median of the current list of numbers can be calculated from the top element of the two heaps.

Let’s take the Example-1 mentioned above to go through each step of our algorithm:

* insertNum(3): We can insert a number in the Max Heap (i.e. first half) if the number is smaller than the top (largest) number of the heap. After every insertion, we will balance the number of elements in both heaps, so that they have an equal number of elements. If the count of numbers is odd, let’s decide to have more numbers in Max Heap than the Min Heap.

![image](https://user-images.githubusercontent.com/25869911/164946923-c74f08f9-1aa1-488b-aabb-50964c7a7e9c.png)

* insertNum(1): As ‘1’ is smaller than ‘3’, let’s insert it into the Max Heap.

![image](https://user-images.githubusercontent.com/25869911/164946932-dd6cde9c-b95c-4d04-91e4-a0b0171ac044.png)

Now, we have two elements in the Max Heap and no elements in Min Heap. Let’s take the largest element from the Max Heap and insert it into the Min Heap, to balance the number of elements in both heaps.

![image](https://user-images.githubusercontent.com/25869911/164946951-bfe6cc98-126e-45f1-97c0-86cf44742c6a.png)

* findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -> (1+3)/2 = 2.0
(1+3)/2=2.0

* insertNum(5): As ‘5’ is greater than the top element of the Max Heap, we can insert it into the Min Heap. After the insertion, the total count of elements will be odd. As we had decided to have more numbers in the Max Heap than the Min Heap, we can take the top (smallest) number from the Min Heap and insert it into the Max Heap.

![image](https://user-images.githubusercontent.com/25869911/164947040-199ee47d-775c-4504-982e-4a1a2d053e64.png)


* findMedian(): Since we have an odd number of elements, the median will be the top element of Max Heap -> 3. An odd number of elements also means that the Max Heap will have one extra element than the Min Heap.
* insertNum(4): Insert ‘4’ into Min Heap.

![image](https://user-images.githubusercontent.com/25869911/164947074-03269a1d-665e-4dee-a43c-2c8eae034d67.png)

* findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -> (3+4)/2 = 3.5
(3+4)/2=3.5

```java
import java.util.*;

class MedianOfAStream {

  PriorityQueue<Integer> maxHeap; // first half of numbers
  PriorityQueue<Integer> minHeap; // second half of numbers

  MedianOfAStream() {
    maxHeap = new PriorityQueue<Integer>((a,b) -> b-a);
    minHeap = new PriorityQueue<Integer>((a,b) -> a-b);
  }

  public void insertNum(int num) {
    // check the input validation
    // when maxHeap is empty alway insert the number first to maxHeap
    // or when the number <= maxHeap peek insert to max heap
    // else insert to the min heap
    if(maxHeap.isEmpty() || num <= maxHeap.peek()) {
      maxHeap.add(num);
    } else {
      minHeap.add(num);
    }

    // balance the two Heaps
    // when compare the max heap to minHeap, we need to add +1 min heap
    // because max heap always have one more number than min heap
    if(maxHeap.size() > minHeap.size()+1) {
      minHeap.add(maxHeap.poll());
    } else if (maxHeap.size() < minHeap.size()) {
      maxHeap.add(minHeap.poll());
    }
  }

  public double findMedian() {
    // when the two heap size is quals is even number the median
    if(maxHeap.size() == minHeap.size()) {
      return (maxHeap.peek()+minHeap.peek())/2.0;
    }

    // when is odd, the median will be maxHeap, maxHeap have always one more number thank minHeap
    return maxHeap.peek();
  }

  public static void main(String[] args) {
    MedianOfAStream medianOfAStream = new MedianOfAStream();
    medianOfAStream.insertNum(3);
    medianOfAStream.insertNum(1);
    System.out.println("The median is: " + medianOfAStream.findMedian());
    medianOfAStream.insertNum(5);
    System.out.println("The median is: " + medianOfAStream.findMedian());
    medianOfAStream.insertNum(4);
    System.out.println("The median is: " + medianOfAStream.findMedian());
  }
}
```

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/295-find-median-from-data-stream

Time complexity

The time complexity of the insertNum() will be O(logN) due to the insertion in the heap. The time complexity of the findMedian() will be O(1) as we can find the median from the top elements of the heaps.

Space complexity

The space complexity will be O(N) because, as at any time, we will be storing all the numbers.
 
### Pattern: Subsets

A huge number of coding interview problems involve dealing with Permutations and Combinations of a given set of elements. This pattern describes an efficient Breadth First Search (BFS) approach to handle all these problems.

Let’s jump onto our first problem to develop an understanding of this pattern.

#### Subsets (easy)

Problem Statement

Given a set with distinct elements, find all of its distinct subsets.

Example 1:

```terminal
Input: [1, 3]
Output: [], [1], [3], [1,3]
```

Example 2:
```terminal
Input: [1, 5, 3]
Output: [], [1], [5], [3], [1,5], [1,3], [5,3], [1,5,3]
```

Solution

To generate all subsets of the given set, we can use the Breadth First Search (BFS) approach. We can start with an empty set, iterate through all numbers one-by-one, and add them to existing sets to create new subsets.

Let’s take the example-2 mentioned above to go through each step of our algorithm:

Given set: [1, 5, 3]

* Start with an empty set: [[]]
* Add the first number (1) to all the existing subsets to create new subsets: [[], [1]];
* Add the second number (5) to all the existing subsets: [[], [1], [5], [1,5]];
* Add the third number (3) to all the existing subsets: [[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]].

Here is the visual representation of the above steps:

![image](https://user-images.githubusercontent.com/25869911/164996777-d75b397a-7498-4128-ae25-819d42278d9f.png)

Since the input set has distinct elements, the above steps will ensure that we will not have any duplicate subsets.

```java
import java.util.*;

class Subsets {

  public static List<List<Integer>> findSubsets(int[] nums) {
    // check some input restriction validation
    // create the subsets tu be returned
    // BFS
    List<List<Integer>> subsets = new ArrayList<List<Integer>>();
    // add the empty list
    subsets.add(new ArrayList<Integer>());
    // traverse the int array
    for(int currentNumber:  nums) {
      // get the size of the subsets
      int subsetSize = subsets.size();
      // we traverse the subsetSizes
      for(int i = 0; i < subsetSize; i++) {
        // create new set copying the subset elements
        List<Integer> set = new ArrayList<Integer>(subsets.get(i));
        // add the currentNumber
        set.add(currentNumber);
        // add the new sets to the subsets
        subsets.add(set);
      }
    }
    return subsets;
  }

  public static void main(String[] args) {
    List<List<Integer>> result = Subsets.findSubsets(new int[] { 1, 3 });
    System.out.println("Here is the list of subsets: " + result);

    result = Subsets.findSubsets(new int[] { 1, 5, 3 });
    System.out.println("Here is the list of subsets: " + result);
  }
}
```
https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/78-subsets

Time complexity#
Since, in each step, the number of subsets doubles as we add each element to all the existing subsets, therefore, we will have a total of O(2^N) subsets, where ‘N’ is the total number of elements in the input set. And since we construct a new subset from an existing set, therefore, the time complexity of the above algorithm will be O(N*2^N).

Space complexity

All the additional space used by our algorithm is for the output list. Since we will have a total of O(2^N) subsets, and each subset can take up to O(N) space, therefore, the space complexity of our algorithm will be O(N*2^N).

### Pattern: Modified Binary Search

As we know, whenever we are given a sorted Array or LinkedList or Matrix, and we are asked to find a certain element, the best algorithm we can use is the Binary Search.

This pattern describes an efficient way to handle all problems involving Binary Search. We will go through a set of problems that will help us build an understanding of this pattern so that we can apply this technique to other problems we might come across in the interviews.

Let’s start with our first problem.

#### Order-agnostic Binary Search (easy)

Problem Statement

Given a sorted array of numbers, find if a given number ‘key’ is present in the array. Though we know that the array is sorted, we don’t know if it’s sorted in ascending or descending order. You should assume that the array can have duplicates.

Write a function to return the index of the ‘key’ if it is present in the array, otherwise return -1.

Example 1:
```terminal
Input: [4, 6, 10], key = 10
Output: 2
```

Example 2:
```terminal
Input: [1, 2, 3, 4, 5, 6, 7], key = 5
Output: 4
```

Example 3:
```terminal
Input: [10, 6, 4], key = 10
Output: 0
```

Example 4:
```terminal
Input: [10, 6, 4], key = 4
Output: 2
```

Solution

To make things simple, let’s first solve this problem assuming that the input array is sorted in ascending order. Here are the set of steps for Binary Search:

* Let’s assume start is pointing to the first index and end is pointing to the last index of the input array (let’s call it arr). This means:

```java
int start = 0;
int end = arr.length - 1;
```

* First, we will find the middle of start and end. An easy way to find the middle would be: middle=(start+end)/2
middle=(start+end)/2. For Java and C++, this equation will work for most cases, but when start or end is large, this equation will give us the wrong result due to integer overflow. Imagine that end is equal to the maximum range of an integer (e.g. for Java: int end = Integer.MAX_VALUE). Now adding any positive number to end will result in an integer overflow. Since we need to add both the numbers first to evaluate our equation, an overflow might occur. The safest way to find the middle of two numbers without getting an overflow is as follows:

```java
 middle  = start + (end-start)/2
 ```
 * The above discussion is not relevant for Python, as we don’t have the integer overflow problem in pure Python.

![image](https://user-images.githubusercontent.com/25869911/164999388-38ee8071-3c01-40a2-97bf-785a58fdbe19.png)

Here is the visual representation of Binary Search for the Example-2:

![image](https://user-images.githubusercontent.com/25869911/164999482-7520062d-1b0b-48e3-bf75-b7465b15ff97.png)

If the array is sorted in the descending order, we have to update the step 4 above as:

* If key > arr[middle], then we can conclude that the key will be greater than all numbers after index middle as the array is sorted in the descending order. Hence, we can reduce our search to end = mid - 1.
* If key < arr[middle], then we can conclude that the key will be smaller than all the numbers before index middle as the array is sorted in the descending order. Hence, we can reduce our search to start = mid + 1.

Finally, how can we figure out the sort order of the input array? We can compare the numbers pointed out by start and end index to find the sort order. If arr[start] < arr[end], it means that the numbers are sorted in ascending order otherwise they are sorted in the descending order.

```java
class BinarySearch {

  public static int search(int[] arr, int key) {
    // check the input validation
    // return -1 when key not founded
    // create the start and end 
    int start = 0, end = arr.length-1;
    // check if the array is asc or desc using the start and end value
    boolean isAscending = arr[start] < arr[end];

    // create the condition to execute binary search
    while (start <= end) {
      // get the middle value, using this formula to evite integer overflow when a value is Integer.MAX_VALUE
      int mid = start+(end-start)/2;
      // check if middle is key value return middle position
      if(key == arr[mid]) return mid;

      // check if the array is asc or desc
      // update the start or end depending where is the key
      if(isAscending) { // asc
        if(key < arr[mid]) end=mid-1;
        else start = mid+1;
      } else { // desc
        if(key > arr[mid]) end=mid-1;
        else start = mid+1;
      }
    }
    return -1;
  }

  public static void main(String[] args) {
    System.out.println(BinarySearch.search(new int[] { 4, 6, 10 }, 10));
    System.out.println(BinarySearch.search(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 5));
    System.out.println(BinarySearch.search(new int[] { 10, 6, 4 }, 10));
    System.out.println(BinarySearch.search(new int[] { 10, 6, 4 }, 4));
  }
}
```

Time complexity

Since, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array.

Space complexity

The algorithm runs in constant space O(1)


### Pattern: Bitwise XOR

XOR is a logical bitwise operator that returns 0 (false) if both bits are the same and returns 1 (true) otherwise. In other words, it only returns 1 if exactly one bit is set to 1 out of the two bits in compariso

![image](https://user-images.githubusercontent.com/25869911/165000143-562c6430-c65c-4676-b3b2-adc9c15deb47.png)

It is surprising to know the approaches that the XOR operator enables us to solve certain problems. For example, let’s take a look at the following problem:

* Given an array of n-1 integers in the range from 1 to n, find the one number that is missing from the array.

Example:
```terminal
Input: 1, 5, 2, 6, 4
Answer: 3
```

A straight forward approach to solve this problem can be:

* Find the sum of all integers from 1 to n; let’s call it s1.
* Subtract all the numbers in the input array from s1; this will give us the missing number.

This is what the algorithm will look like:

```java
import java.util.*;

public class MissingNumber {
    
    private static int findMissingNumber(int[] array) {
        // get the size of the numbers to sum
        int size = array.length+1;
        // create sum and for to sum all numbers
        int missingNum = 0;
        
        for(int i = 1; i <= size; i++) {
            missingNum += i;
        }
        
        // to found the missing number we just rest the array number from sum
        for(int num: array) {
            missingNum -= num;    
        }
        
        return missingNum;
    }

    public static void main(String args[]) {
        int[] arr = new int[] { 1, 5, 2, 6, 4 };
        System.out.print("Missing number is: " + MissingNumber.findMissingNumber(arr));
    }
}
```

Time & Space complexity: The time complexity of the above algorithm is O(n) and the space complexity is O(1)

What could go wrong with the above algorithm?

* While finding the sum of numbers from 1 to n, we can get integer overflow when n is large

Remember the important property of XOR that it returns 0 if both the bits in comparison are the same. In other words, XOR of a number with itself will always result in 0. This means that if we XOR all the numbers in the input array with all numbers from the range 1 to n then each number in the input is going to get zeroed out except the missing number. Following are the set of steps to find the missing number using XOR:
 
* XOR all the numbers from 1 to n, let’s call it x1.
* XOR all the numbers in the input array, let’s call it x2.
* The missing number can be found by x1 XOR x2.

Here is what the algorithm will look like:

```java
import java.util.*;

public class MissingNumber {
    
    private static int findMissingNumber(int[] arr) {
       // get the sum of xor 1 to n
       // get the size of n
       int n = arr.length+1;
       int x0 = 1;
       for(int i=2; i <= n; i++) {
           x0 ^= i; 
       }
       
       // get the xor values of the array
       int x1 = arr[0];
       for(int i=1; i < n-1; i++) {
           x1 ^= arr[i];
       }
       
       // return the missing number 
       return x0^x1;
       
    }

    
    public static void main(String args[]) {
        int[] arr = new int[] { 1, 5, 2, 6, 4 };
        System.out.print("Missing number is: " + MissingNumber.findMissingNumber(arr));
    }
}
```

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/268-missing-number

Time & Space complexity: The time complexity of the above algorithm is O(n) and the space complexity is O(1). The time and space complexities are the same as that of the previous solution but, in this algorithm, we will not have any integer overflow problem.

Important properties of XOR to remember

Following are some important properties of XOR to remember:

Taking XOR of a number with itself returns 0, e.g.,
```terminal
1 ^ 1 = 0
29 ^ 29 = 0
```   
Taking XOR of a number with 0 returns the same number, e.g.,
```terminal
1 ^ 0 = 1
31 ^ 0 = 31
```
XOR is Associative & Commutative, which means:
```terminal
(a ^ b) ^ c = a ^ (b ^ c)
a ^ b = b ^ a
```
In the following chapters, we will apply the XOR pattern to solve some interesting problems.

#### Single Number (easy)


Problem Statement

In a non-empty array of integers, every number appears twice except for one, find that single number.

Example 1:
```terminal
Input: 1, 4, 2, 1, 3, 2, 3
Output: 4
```
Example 2:
```terminal
Input: 7, 9, 7
Output: 9
```

Solution

One straight forward solution can be to use a HashMap kind of data structure and iterate through the input:

* If number is already present in HashMap, remove it.
* If number is not present in HashMap, add it.
* In the end, only number left in the HashMap is our required single number.

Time and space complexity Time Complexity of the above solution will be O(n) and space complexity will also be O(n)

Can we do better than this using the XOR Pattern?

Solution with XOR

Recall the following two properties of XOR:

* It returns zero if we take XOR of two same numbers.
* It returns the same number if we XOR with zero.

So we can XOR all the numbers in the input; duplicate numbers will zero out each other and we will be left with the single number.

```java
class SingleNumber {
  public static int findSingleNumber(int[] arr) {
    // first start with 0
    int num = 0;
    // do xor for every element
    // xor property is if is same number will return 0
    // xor of constant with 0 will return constant
    for(int i = 0; i < arr.length; i++) {
      num = num^arr[i];
    }

    return num;

  }

  public static void main( String args[] ) {
    System.out.println(findSingleNumber(new int[]{1, 4, 2, 1, 3, 2, 3}));
  }
}
```

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/136-single-number

Time Complexity: Time complexity of this solution is O(n) as we iterate through all numbers of the input once.

Space Complexity: The algorithm runs in constant space O(1).

### Pattern: Top 'K' Elements

Any problem that asks us to find the top/smallest/frequent ‘K’ elements among a given set falls under this pattern.

The best data structure that comes to mind to keep track of ‘K’ elements is Heap. This pattern will make use of the Heap to solve multiple problems dealing with ‘K’ elements at a time from a set of given elements.

Let’s jump onto our first problem to develop an understanding of this pattern.

#### Top 'K' Numbers (easy)

Problem Statement

Given an unsorted array of numbers, find the ‘K’ largest numbers in it.

Note: For a detailed discussion about different approaches to solve this problem, take a look at Kth Smallest Number.

Example 1:
```terminal
Input: [3, 1, 5, 12, 2, 11], K = 3
Output: [5, 12, 11]
```

Example 2:
```terminal
Input: [5, 12, 11, -1, 12], K = 3
Output: [12, 11, 12]
```

Solution

A brute force solution could be to sort the array and return the largest K numbers. The time complexity of such an algorithm will be O(N*logN) as we need to use a sorting algorithm like Timsort if we use Java’s Collection.sort(). Can we do better than that?

The best data structure that comes to mind to keep track of top ‘K’ elements is Heap. Let’s see if we can use a heap to find a better algorithm.

If we iterate through the array one element at a time and keep ‘K’ largest numbers in a heap such that each time we find a larger number than the smallest number in the heap, we do two things:

* Take out the smallest number from the heap, and
* Insert the larger number into the heap.

This will ensure that we always have ‘K’ largest numbers in the heap. The most efficient way to repeatedly find the smallest number among a set of numbers will be to use a min-heap. As we know, we can find the smallest number in a min-heap in constant time O(1), since the smallest number is always at the root of the heap. Extracting the smallest number from a min-heap will take O(logN) (if the heap has ‘N’ elements) as the heap needs to readjust after the removal of an element.

Let’s take Example-1 to go through each step of our algorithm:

Given array: [3, 1, 5, 12, 2, 11], and K=3

* First, let’s insert ‘K’ elements in the min-heap.
* After the insertion, the heap will have three numbers [3, 1, 5] with ‘1’ being the root as it is the smallest element.
* We’ll iterate through the remaining numbers and perform the above-mentioned two steps if we find a number larger than the root of the heap.
* The 4th number is ‘12’ which is larger than the root (which is ‘1’), so let’s take out ‘1’ and insert ‘12’. Now the heap will have [3, 5, 12] with ‘3’ being the root as it is the smallest element.
* The 5th number is ‘2’ which is not bigger than the root of the heap (‘3’), so we can skip this as we already have top three numbers in the heap.
* The last number is ‘11’ which is bigger than the root (which is ‘3’), so let’s take out ‘3’ and insert ‘11’. Finally, the heap has the largest three numbers: [5, 12, 11]

As discussed above, it will take us O(logK) to extract the minimum number from the min-heap. So the overall time complexity of our algorithm will be O(K*logK+(N-K)*logK) since, first, we insert ‘K’ numbers in the heap and then iterate through the remaining numbers and at every step, in the worst case, we need to extract the minimum number and insert a new number in the heap. This algorithm is better than O(N*logN)

Here is the visual representation of our algorithm:

![image](https://user-images.githubusercontent.com/25869911/165007632-3a657335-d3cb-4f12-b82a-555d31a2a6b5.png)

![image](https://user-images.githubusercontent.com/25869911/165007702-05526f7e-7d3b-4667-9339-b31a45b2dcc7.png)

![image](https://user-images.githubusercontent.com/25869911/165007730-f7e10093-9c2c-40d8-ac97-ff0d7e385ca3.png)

![image](https://user-images.githubusercontent.com/25869911/165007764-5e3d2d71-a985-4aa0-be39-d29f4a947c68.png)

```java
import java.util.*;

class KLargestNumbers {

  public static List<Integer> findKLargestNumbers(int[] nums, int k) {
    // check the input validation
    // declare the minHeap as PriorityQueue
    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();
    // traverse from 0 to k ,  insert the first k elements in the minHeap
    for(int i=0; i < k; i++) minHeap.add(nums[i]);

    // traverse from k to array size
    // if the nums[j] > minHeap peek, pull the peek and the value
    for(int j=k; j < nums.length; j++) {
      if(nums[j] > minHeap.peek()) {
        minHeap.poll();
        minHeap.add(nums[j]);
      }
    }

    // return the minHeap as arrayList
    return new ArrayList<Integer>(minHeap);

  }

  public static void main(String[] args) {
    List<Integer> result = KLargestNumbers.findKLargestNumbers(new int[] { 3, 1, 5, 12, 2, 11 }, 3);
    System.out.println("Here are the top K numbers: " + result);

    result = KLargestNumbers.findKLargestNumbers(new int[] { 5, 12, 11, -1, 12 }, 3);
    System.out.println("Here are the top K numbers: " + result);
  }
}
```

Time complexity

As discussed above, the time complexity of this algorithm is O(K*logK+(N-K)*logK), which is asymptotically equal to O(N*logK)

Space complexity

The space complexity will be O(K) since we need to store the top ‘K’ numbers in the heap.


### Pattern: K-way merge

This pattern helps us solve problems that involve a list of sorted arrays.

Whenever we are given ‘K’ sorted arrays, we can use a Heap to efficiently perform a sorted traversal of all the elements of all arrays. We can push the smallest (first) element of each sorted array in a Min Heap to get the overall minimum. While inserting elements to the Min Heap we keep track of which array the element came from. We can, then, remove the top element from the heap to get the smallest element and push the next element from the same array, to which this smallest element belonged, to the heap. We can repeat this process to make a sorted traversal of all elements.

Let’s see this pattern in action.

#### Merge K Sorted Lists (medium)

Problem Statement

Given an array of ‘K’ sorted LinkedLists, merge them into one sorted list.

Example 1:
```terminal
Input: L1=[2, 6, 8], L2=[3, 6, 7], L3=[1, 3, 4]
Output: [1, 2, 3, 3, 4, 6, 6, 7, 8]
```

Example 2:
```terminal
Input: L1=[5, 8, 9], L2=[1, 7]
Output: [1, 5, 7, 8, 9]
```

Solution

A brute force solution could be to add all elements of the given ‘K’ lists to one list and sort it. If there are a total of ‘N’ elements in all the input lists, then the brute force solution will have a time complexity of O(N*logN) as we will need to sort the merged list. Can we do better than this? How can we utilize the fact that the input lists are individually sorted?

If we have to find the smallest element of all the input lists, we have to compare only the smallest (i.e. the first) element of all the lists. Once we have the smallest element, we can put it in the merged list. Following a similar pattern, we can then find the next smallest element of all the lists to add it to the merged list.

The best data structure that comes to mind to find the smallest number among a set of ‘K’ numbers is a Heap. Let’s see how can we use a heap to find a better algorithm.

* We can insert the first element of each array in a Min Heap.
* After this, we can take out the smallest (top) element from the heap and add it to the merged list.
* After removing the smallest element from the heap, we can insert the next element of the same list into the heap.
* We can repeat steps 2 and 3 to populate the merged list in sorted order.

Let’s take the Example-1 mentioned above to go through each step of our algorithm:

Given lists: L1=[2, 6, 8], L2=[3, 6, 7], L3=[1, 3, 4]

* After inserting the 1st element of each list, the heap will have the following elements:

![image](https://user-images.githubusercontent.com/25869911/165009727-02cfabb4-eac3-43c7-ae7c-c3cf5bb39c63.png)

* We’ll take the top number from the heap, insert it into the merged list and add the next number in the heap.

![image](https://user-images.githubusercontent.com/25869911/165009793-0d9f5fa9-1c76-4375-b8ee-7c23d146147c.png)

* Again, we’ll take the top element of the heap, insert it into the merged list and add the next number to the heap.

![image](https://user-images.githubusercontent.com/25869911/165009843-b080caaf-57d4-4d85-a89c-6f62c01ca084.png)

* Repeating the above step, take the top element of the heap, insert it into the merged list and add the next number to the heap. As there are two 3s in the heap, we can pick anyone but we need to take the next element from the corresponding list to insert in the heap.

![image](https://user-images.githubusercontent.com/25869911/165009907-2ecb6c96-a5b9-4f82-9c63-69fb0d1abe99.png)

We’ll repeat the above step to populate our merged array.

```java
import java.util.*;

class ListNode {
    int value;
    ListNode next;
    
    ListNode(int value) {
        this.value = value;
    }
}

public class MergeKSortedLists {
    
    private static ListNode merge(ListNode[] lists) {
        
        // input validationt
        // create the minHeap of priortyQueue
        PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a,b) -> a.value-b.value);
        
        // add the first 3 root node to the minHeap
        for(ListNode root: lists) {
            if(root != null) minHeap.add(root);
        }
        
        // we need to create head and tail node
        // add the minHeap peek minor element to the node
        // condition to traverse minheap is not empty
        ListNode headNode = null, tailNode= null;
        while(!minHeap.isEmpty()) {
            // pull the peek element
            ListNode node = minHeap.poll();
            // first time
            if(headNode == null) headNode = tailNode = node;
            else {
                tailNode.next = node;
                tailNode = tailNode.next;
            }
            // need to add the next element of the node to minHeap
            if(node.next != null) minHeap.add(node.next);
        }
        
        // return the head
        return headNode;
   
    }

    
    public static void main(String args[]) {
        ListNode l1 = new ListNode(2);
        l1.next = new ListNode(6);
        l1.next.next = new ListNode(8);
    
        ListNode l2 = new ListNode(3);
        l2.next = new ListNode(6);
        l2.next.next = new ListNode(7);
    
        ListNode l3 = new ListNode(1);
        l3.next = new ListNode(3);
        l3.next.next = new ListNode(4);
        
        ListNode result = MergeKSortedLists.merge(new ListNode[] {l1,l2,l3});
        while(result != null) {
            System.out.print(result.value+" ");
            result = result.next;
        }
    }
}
```

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/21-merge-two-sorted-lists

Time complexity

Since we’ll be going through all the elements of all arrays and will be removing/adding one element to the heap in each step, the time complexity of the above algorithm will be O(N*logK), where ‘N’ is the total number of elements in all the ‘K’ input arrays.

Space complexity

The space complexity will be O(K) because, at any time, our min-heap will be storing one number from all the ‘K’ input arrays.

### Pattern : 0/1 Knapsack (Dynamic Programming)

0/1 Knapsack pattern is based on the famous problem with the same name which is efficiently solved using Dynamic Programming (DP).

In this pattern, we will go through a set of problems to develop an understanding of DP. We will always start with a brute-force recursive solution to see the overlapping subproblems, i.e., realizing that we are solving the same problems repeatedly.

After the recursive solution, we will modify our algorithm to apply advanced techniques of Memoization and Bottom-Up Dynamic Programming to develop a complete understanding of this pattern.

Let’s jump onto our first problem.

#### 0/1 Knapsack (medium)

Introduction

Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack with a capacity ‘C.’ The goal is to get the maximum profit out of the knapsack items. Each item can only be selected once, as we don’t have multiple quantities of any item.

Let’s take Merry’s example, who wants to carry some fruits in the knapsack to get maximum profit. Here are the weights and profits of the fruits:

Items: { Apple, Orange, Banana, Melon }
Weights: { 2, 3, 1, 4 }
Profits: { 4, 5, 3, 7 }
Knapsack capacity: 5

Let’s try to put various combinations of fruits in the knapsack, such that their total weight is not more than 5:

Apple + Orange (total weight 5) => 9 profit
Apple + Banana (total weight 3) => 7 profit
Orange + Banana (total weight 4) => 8 profit
Banana + Melon (total weight 5) => 10 profit

This shows that Banana + Melon is the best combination as it gives us the maximum profit, and the total weight does not exceed the capacity.

Problem Statement

Given two integer arrays to represent weights and profits of ‘N’ items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number ‘C.’ Each item can only be selected once, which means either we put an item in the knapsack or we skip it.

Basic Solution

A basic brute-force solution could be to try all combinations of the given items (as we did above), allowing us to choose the one with maximum profit and a weight that doesn’t exceed ‘C’. Take the example of four items (A, B, C, and D), as shown in the diagram below. To try all the combinations, our algorithm will look like:

```terminal
for each item 'i' 
  create a new set which INCLUDES item 'i' if the total weight does not exceed the capacity, and 
     recursively process the remaining capacity and items
  create a new set WITHOUT item 'i', and recursively process the remaining items 
return the set from the above two sets with higher profit 
```

Here is a visual representation of our algorithm

![image](https://user-images.githubusercontent.com/25869911/165218254-45d59e15-ed07-4da3-b460-b2c8e8576675.png)

All green boxes have a total weight that is less than or equal to the capacity (7), and all the red ones have a weight that is more than 7. The best solution we have is with items [B, D] having a total profit of 22 and a total weight of 7.

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return this.knapsackRecursive(profits, weights, capacity, 0);
  }

  private int knapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex) {
    // check the input validation
    if (capacity <=0 || currentIndex >= profits.length) return 0;

    // get the first profit only if the weights[currentIndex] <= capacity
    // we need to get currentIndex proftis, sum with the knapsack recursive method
    // that rest the capacity of the current wieghts and the index need to incremente
    int profitAdded = 0;
    if(weights[currentIndex] <= capacity) {
      profitAdded = profits[currentIndex] + knapsackRecursive(profits,weights, capacity- weights[currentIndex],currentIndex+1);
    }

    // recursive call to the profit skipped
    int profitSkipped = knapsackRecursive(profits, weights, capacity, currentIndex+1);

    // return the max from two profits
    return Math.max(profitAdded, profitSkipped);

  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

Time and Space complexity

The above algorithm’s time complexity is exponential O(2^n), where ‘n’ represents the total number of items. This can also be confirmed from the above recursion tree. As we can see, we will have a total of ‘31’ recursive calls – calculated through (2^n) + (2^n) - 1, which is asymptotically equivalent to O(2^n)

The space complexity is O(n). This space will be used to store the recursion stack. Since the recursive algorithm works in a depth-first fashion, which means that we can’t have more than ‘n’ recursive calls on the call stack at any time.

Overlapping Sub-problems: Let’s visually draw the recursive calls to see if there are any overlapping sub-problems. As we can see, in each recursive call, profits and weights arrays remain constant, and only capacity and currentIndex change. For simplicity, let’s denote capacity with ‘c’ and currentIndex with ‘i’:

![image](https://user-images.githubusercontent.com/25869911/165220169-beb170fe-ff93-4405-a043-a29eda2ce18a.png)

We can clearly see that ‘c:4, i=3’ has been called twice. Hence we have an overlapping sub-problems pattern. We can use Memoization to solve overlapping sub-problems efficiently.


### Top-down Dynamic Programming with Memoization

Memoization is when we store the results of all the previously solved sub-problems and return the results from memory if we encounter a problem that has already been solved.

Since we have two changing values (capacity and currentIndex) in our recursive function knapsackRecursive(), we can use a two-dimensional array to store the results of all the solved sub-problems. As mentioned above, we need to store results for every sub-array (i.e., for every possible index ‘i’) and every possible capacity ‘c.’

Here is the code with memoization (see changes in the highlighted lines):

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // use double array as memoization
    Integer[][] dp = new Integer[profits.length][capacity+1];
    return this.knapsackRecursive(dp, profits, weights, capacity, 0);
  }

  private int knapsackRecursive(Integer[][] dp, int[] profits, int[] weights, int capacity, int currentIndex) {
    // input validation
    if( capacity <= 0 || currentIndex >= profits.length) return 0;

    // check if the values existed in memoization
    if(dp[currentIndex][capacity] != null) return dp[currentIndex][capacity];

    // get the profitAdded
    // check weight of current index <= capacity
    // add the current Profits, and recursive call the next profit, but subtracting the current weight
    // in the capacity and currentIndex need to incremented
    int profitAdded = 0;
    if(weights[currentIndex] <= capacity) {
      profitAdded = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity- weights[currentIndex], currentIndex+1);
    }

    // create the profitSkipped just calling the next index
    int profitSkipped = knapsackRecursive(dp, profits, weights, capacity, currentIndex+1);

    //store the values in the memoization
    //return the only max of two profits
    dp[currentIndex][capacity] = Math.max(profitAdded, profitSkipped);
    return dp[currentIndex][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```
Time and Space complexity

Since our memoization array dp[profits.length][capacity+1] stores the results for all subproblems, we can conclude that we will not have more than N*C subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be O(N*C).

The above algorithm will use O(N*C) space for the memoization array. Other than that, we will use O(N) space for the recursion call-stack. So the total space complexity will be O(N*C + N), which is asymptotically equivalent to O(N*C).

Bottom-up Dynamic Programming

Let’s try to populate our dp[][] array from the above solution by working in a bottom-up fashion. Essentially, we want to find the maximum profit for every sub-array and every possible capacity. This means that dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.

So, for each item at index ‘i’ (0 <= i < items.length) and capacity ‘c’ (0 <= c <= capacity), we have two options:

* Exclude the item at index ‘i.’ In this case, we will take whatever profit we get from the sub-array excluding this item => dp[i-1][c]
* Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items => profit[i] + dp[i-1][c-weight[i]]

Finally, our optimal solution will be maximum of the above two values:

* dp[i][c] = max (dp[i-1][c], profit[i] + dp[i-1][c-weight[i]]) 

Let’s draw this visually and start with our base case of zero capacity:

![image](https://user-images.githubusercontent.com/25869911/165224663-6a78ca86-6821-46b5-b102-afe4557069d4.png)

![image](https://user-images.githubusercontent.com/25869911/165224743-bb3a463a-5448-43ee-857e-3ee2e587cc93.png)

![image](https://user-images.githubusercontent.com/25869911/165224802-c9250e03-7bbe-40d0-b87d-faa1c8da5d28.png)

![image](https://user-images.githubusercontent.com/25869911/165224857-0ec684a1-2923-4dab-b123-b344b1672bf4.png)

![image](https://user-images.githubusercontent.com/25869911/165224957-3a451565-4710-4386-87a8-b0b761018978.png)

