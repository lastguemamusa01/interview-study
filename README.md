# interview-study
interview study materials 101


## Interview exposed book

1 - bofre the search

find what kind of programmer your are(what do you like to do)

application dev

short-term projects


Visit two kinds of job sites as part of your research. Job listing sites such as Dice (which specializes in technology-related career listings), Indeed, and Monster (general job listing sites) enable you to see what kinds of jobs are currently in demand. Review sites such as Glassdoor discuss working conditions, salaries, bonuses, perks, and other informa- tion useful for finding the right kind of company for you.

No contracts and no offshore


Another way to make yourself more difficult to replace is to acquire domain specific knowledge: expertise related to the programs you write but outside of the field of programming. For example, if you develop financial software, it’s much more difficult to out- source your job if it involves the application of accounting skills in addition to programming than if you’re purely a coder.

develop marketable skills

* participating in programming contests
* proffeesional development courses - coursera, etc
* master or doctorate degree
* don't bother with certifications
* work on side project , or open source development
* Use code contest sites. TopCoder, HackerRank, CodeWars, and several similar sites have developers “face-off” to solve programming problems. If you win, meaning you solve the problem faster than the competitor or bot, you move up the leaderboards and get a higher rank, which you can make public and list on your résumé.

Companies look for software developers who get things done. You may look great on paper in terms of skills and education, but credentials and knowledge don’t make products or services that a company can sell. It’s your ability to accomplish something that truly sets you apart from the other candidates.

Your online profile—everything public about you online—is just as important as your résumé. Recruiters use online profiles to find desirable candidates

* Google search results for your name. This is the first impression you make on potential employers and colleagues.
* LinkedIn profile. LinkedIn is a social network for tracking professional connections. It’s free to join, and you can create a detailed profile about yourself, including your jobs and your education—essentially an online résumé. Colleagues and customers can publicly endorse you or your work, which can be quite valuable.
* GitHub profile. Many employers will evaluate your work through your GitHub profile well before they meet you. Take a look and spend a few hours to clean up your GitHub profile so it reflects your best code. Delete or change the privacy settings for incomplete, poorly orga- nized, or low-quality repositories. Assume your profile may be checked even before you’re asked about it. If you don’t have very much public, move your best code to public so it’s clear that you have significant code and experience with GitHub.
* Stack Overflow. This will show up on your Google search result, or may be checked. If you have recent, basic questions that reflect poorly on your knowledge, you may want to delete them. If you don’t have a profile, you should make one, especially if your job search is still a few months out and you have time to answer other people’s questions.
* Angel investor sites. These sites don’t just connect investors with startups, they also connect startups with potential hires. AngelList is the big player in this category. Create a profile that reflects your interests and expertise.
* Other social network profiles. Other social networks such as Facebook, Twitter, or Snapchat may be reviewed, depending on your privacy settings. Make sure you clean up and tighten your profile so nothing unprofessional appears public.
* Personal website. This is a potential source of more in-depth information about you and top- ics you find interesting. If you blog about political or controversial topics, you may want to remove such posts during your job search.
* Articles and blog posts. If you write about programming-related topics, this is a good way for recruiters to assess your experience.
* Comments and forum posts. These provide another way to gain some insight into your pro- gramming skills and your general attitude toward technology and technology companies.


WARNING One caveat about updating your LinkedIn profile: by default, all your contacts are notified of your updates. Many people have learned to inter- pret these notifications as de facto announcements that someone is looking for a new job. That might help you get the word out, but if your contacts include people at your current company and you don’t want them to know you’re look- ing for a new job, disable these notifications before you make your updates.

What you do before a formal job search is critical to finding the right kind of job. With that in mind, you should consider the following things:

* Know your likes and dislikes as a programmer and a prospective employee.
* Understand the market to find and apply for the best jobs.
* Develop the marketable skills that employers look for and that can enhance your career.
* Manage your public profile to show you in the best possible light and make sure there are no surprises to turn off potential employers.


## 2 - the job application process


Interviewing and recruiting procedures are similar at most tech companies, so the more pre- pared you are for what you will encounter, the more successful you will be. This chapter familiarizes you with the entire job-search process, from contacting companies to starting your new job, so you won’t need to write off your first few application attempts as learning experiences.

FINDING AND CONTACTING COMPANIES

The first step to getting a job is to find and make contact with companies you’re interested in working for. Although referrals are the best way to land a job, you can also work with head- hunters or contact a company directly.


* decide the companies that you are going to apply
* add the all known people in facebook or linked in who working that company that you want to work
* top coder, hackerrank and codewars.
* applied in the offitial page -> headhunter or referrals


After you’ve been given a specific offer that includes details about salary, signing bonus, benefits, and possibly stock options, you need to decide whether you’re satisfied with it. This shouldn’t be a snap decision—never accept an offer on the spot. Always spend at least a day thinking about impor- tant decisions such as this; it’s surprising how much can change in a day.


Negotiating Your Salary

If, after careful consideration, the offer meets or exceeds your expectations, you’re all set. On the other hand, if you’re not completely happy with your offer, you should try to negotiate. Most people ask for too little, as opposed to too much. Don’t be afraid to “lean in,” no matter who you are or

what your background is. All too often, applicants assume that offers are nonnegotiable and reject them without negotiation or accept offers they’re not pleased with. Almost every offer is negotiable to some extent.


You can find prospective jobs in various ways, but networking through friends and acquaintances is usually the best method. If that’s not possible, find and contact companies directly. You may also engage the services of a headhunter; be aware that the headhunter’s motivations aren’t always aligned with yours.
The interviews are the most important part of the job application process. You will have one or two screening interviews, usually by phone, to ensure that you’re applying for the right job and that you are actually qualified. After the screening interviews, you’ll usually go through a series of on-site technical interviews that ultimately determine whether a job offer comes your way. Be sure to dress appropriately for the interviews, and turn off any electronic gadgets you might have with you.
During the interview process you’ll frequently interact with one of the company’s recruiters, espe- cially if a job offer is made. Be sure to understand the recruiter’s role during this process.
When an offer is made, don’t accept it immediately. Give yourself time to consider it. Look over the offer, and try to negotiate a better deal because most offers aren’t fixed in stone, no matter what the recruiter says. After accepting a job offer, be sure to contact anyone else who has made you an offer to thank them for their interest in you.

phone screen interview(1st interview)

Knowledge-based questions are common during on-site interviews as well as phone screens -> from you resume one or two

some basic coding and design tasks.


Instead, many of these problems require algorithmic tricks or uncommonly used features of a language.

The problems often prohibit you from using the most common way to do something or from using the ideal data structure. For example, you might be given a problem such as: “Write a function that determines whether two integers are equal without using any comparison operators.”

Interactivity Is Key
The code you write in the interview is probably the only example of your code that your interviewer sees. If you write ugly code, your interviewer will assume you always write ugly code. This is your chance to shine and show your best code. Take the time to make your code solid and pretty.


What the interviewer wants is to see your thought processes as you work through each stage of the programming problem.

The problem-solving process in these interviews is interactive, and if you have difficulty, the inter- viewer generally guides you to the correct answer via a series of hints. Of course, the less help you need to solve the problem, the better you look, but showing an intelligent thought process and responding well to the hints you are given is also important. 

 Break down the answer into discrete steps and explain the thought processes behind each step.
 
 Keep talking! Always explain what you are doing. Otherwise, the inter- viewer has no way of knowing how you tackle complex programming problems.
 
When you begin solving a problem, don’t start writing code immediately. First, make sure you com- pletely understand the problem. It may help to work through a simple, concrete example and then try to generalize the process to an algorithm. When you’re convinced you have the right algorithm, explain it clearly. Writing the code should be one of your final steps.
 

1 - Make sure you understand the problem. Your initial assumptions about the problem may be wrong, or the interviewer’s explanation may be brief or difficult to follow. You can’t demon- strate your skills if you don’t understand the problem. Don’t hesitate to ask your interviewer questions, and don’t start solving the problem until you understand it. The interviewer may be deliberately obscuring things to determine whether you can find and understand the actual problem. In these cases, asking the right clarifying questions is an important part of the cor- rect solution.

2 - When you understand the question, try a simple example. This example may lead to insights about how to solve the general problem or bring to light any remaining misunderstandings that you have. Starting with an example also demonstrates a methodical, logical thought process. Examples are especially useful if you don’t see the solution right away.

3 - Focus on the algorithm and data structures you will use to solve the problem. This can take a long time and require additional examples. This is to be expected. Interactivity is important during this process. If you stand quietly staring at the whiteboard, the interviewer has no way of knowing whether you’re making productive headway or are simply clueless. Talk to your interviewer about what you are doing. For example, you might say something like, “I’m wondering whether I can store the values in an array and then sort them, but I don’t think that will work because I can’t quickly look up elements in an array by value.” This demon- strates your skill, which is the point of the interview, and may also lead to hints from the interviewer, who might respond, “You’re close to the solution. Do you really need to look up elements by value, or could you....”

It may take a long time to solve the problem, and you may be tempted to begin coding before you figure out a complete solution. Resist this temptation. Consider who you would rather work with: someone who thinks about a problem for a long time and then codes it correctly the first time or someone who hastily jumps into a problem, makes several errors while cod- ing, and doesn’t have any idea what direction to take. Not a difficult decision, is it?

4 - After you figure out your algorithm and how you can implement it, explain your solution
to the interviewer. This provides an opportunity to evaluate your solution before you begin coding. Your interviewer may say, “Sounds great, go ahead and code it,” or something
like, “That’s not quite right because you can’t look up elements in a hash table that way.” Another common response is “That sounds like it will work, but there’s a more efficient solu- tion.” In any case, you gain valuable information about whether you should move on to cod- ing or go back to working on the algorithm.

5 - While you code, explain what you’re doing. For example, you might say, “Here, I’m initial- izing the array to all zeros.” This narrative enables the interviewer to follow your code more easily.


6- Ask questions when necessary. You generally won’t be penalized for asking factual questions that you might otherwise look up in a reference. You obviously can’t ask a question such
as, “How do I solve this problem?” but it is acceptable to ask a question such as, “I can’t remember—what format string do I use to print out a localized date?” Although it’s better to know these things, it’s okay to ask this sort of question.

7- After you write the code for a problem, immediately verify that the code works by tracing through it with an example. This step demonstrates clearly that your code is correct in at least one case. It also illustrates a logical thought process and your intention to check your work and search for bugs. The example may also help you flush out minor bugs in your solution.

8- Make sure you check your code for all error and special cases, especially boundary condi- tions. Programmers often overlook error and special cases; forgetting these cases in an interview indicates you might forget them on the job. If time does not allow for extensive checking, at least explain that you should check for such failures. Covering error and special cases can impress your interviewer and help you correctly solve the problem.

After you try an example and feel comfortable that your code is correct, the interviewer may ask you questions about what you wrote. These questions often focus on running time, alternative implementations, and complexity (discussed later in this chapter). If your interviewer does not ask you these questions, you should volunteer the information to show that you are cognizant of these issues. For example, you could say, “This implementation has linear running time, which is the best achievable running time since I need to check all the input values. The dynamic memory allocation will slow it down a little, as will the overhead of using recursion.”

When You Get Stuck

Getting stuck on a problem is expected and an important part of the interviewing process. Interviewers want to see how you respond when you don’t recognize the answer to a question imme- diately. Giving up or getting frustrated is the worst thing to do if this happens to you. Instead, show interest in the problem and keep trying different ways to solve it:

* Go back to an example. Try performing the task and analyzing what you are doing. Try extending your specific example to the general case. You may have to use detailed examples. This is okay, because it shows the interviewer your persistence in finding the correct solution.

* Try a different data structure. Perhaps a linked list, an array, a hash table, or a binary search tree can help. If you’re given an unusual data structure, look for similarities between it and more familiar data structures. Using the right data structure often makes a problem much easier.

* Consider the less commonly used or more advanced aspects of a language. Sometimes the key to a problem involves one of these features.


Even when you don’t feel stuck, you may not be converging on the optimal solution. You may miss an elegant or nonobvious way to implement something. Pause every once in a while to reconsider the bigger picture and whether there may be a better approach. One sign that you may be off track is if you find yourself writing too much code. Almost all interview coding questions have short answers. You rarely need to write more than 30 lines of code and almost never more than 50. If you start writing a lot of code, you may be heading in the wrong direction.

### ANALYZING YOUR SOLUTION

After you answer the problem, you may be asked about the efficiency of your implementation. Often, you have to compare trade-offs between your implementation and another possible solution and identify the conditions that make each option more favorable. Common questions focus on run time and memory usage.

A good understanding of Big-O analysis is critical to making a good impression with the inter- viewer. Big-O analysis is a form of runtime analysis that measures the efficiency of an algorithm in terms of the time it takes for the algorithm to run as a function of the input size. It’s not a formal benchmark, just a simple way to classify algorithms by relative efficiency when dealing with very large input sizes.
Most coding problem solutions in this book include a runtime analysis to help you solidify your understanding of the algorithms.


Best, Average, and Worst Cases
You may think this comparison was stacked against CompareToAll because the maximum value was at the end. This is true, and it raises the important issues of best-case, average-case, and worst-case running times. The analysis of CompareToAll was a worst-case scenario: the maximum value was at the end of the array. Consider the average case, in which the largest value is in the middle. You end up checking only half the values n times because the maximum value is in the middle. This results
in checking n(n/2) = n2/2 times. This would appear to be an O(n2/2) running time. However, Big-O analysis is concerned with the way the running time changes as the input becomes very large. As n increases toward infinity, the difference between n2/2 and n2 become negligible relative to the differ- ence between n2 and any other functional form (e.g., n or n3). Therefore, in Big-O analysis, you drop all constant factors, just as you drop all lower order terms. This is why you can consider the time
for every operation to be equivalent: considering different constant time requirements for different operations would yield a constant multiplicative factor, which you would drop anyway. With this in mind, the average case for CompareToAll is no better than the worst case. It is still O(n2).

The best-case running time for CompareToAll is better than O(n2). In this case, the maximum value is at the beginning of the array. The maximum value is compared to all other values only once, so the result is an O(n) running time.

In CompareToMax, the best-case, average-case, and worst-case running times are identical. Regardless of the arrangement of the values in the array, the algorithm is always O(n).

Ask interviewers which scenario they’re most interested in. Sometimes you’ll find clues to this in the problem. Some sorting algorithms with terrible worst cases for unsorted data may nonetheless be well suited for a problem if the input is already sorted. These kinds of trade-offs are discussed in

The fastest possible running time for any runtime analysis is O(1), commonly referred to as con- stant running time. An algorithm with constant running time always takes the same amount of time to execute, regardless of the input size. This is the ideal run time for an algorithm, but it’s rarely achievable.

* O(log n). An algorithm is said to be logarithmic if its running time increases logarithmically in proportion to the input size.
log 10 = 1

* O(n). A linear algorithm’s running time increases in direct proportion to the input size.
10 = 10

* O(n log n). A quasilinear algorithm is midway between a linear algorithm and a polynomial
algorithm.
10 log 10 = 10 

* O(n^c). A polynomial algorithm grows quickly based on the size of the input.
10^2 = 100

* O(c^n). An exponential algorithm grows even faster than a polynomial algorithm.
2^10= 1,024

* O(n!). A factorial algorithm grows the fastest and becomes quickly unusable for even small
values of n.
10! = 3,628,800

Memory Footprint Analysis

Runtime analysis is not the only relevant metric for performance. A common request from inter- viewers is to analyze how much memory a program uses. This is sometimes referred to as the memory footprint of the application. Memory use is sometimes as important as running time, par- ticularly in constrained environments such as embedded systems.

In some cases, you will be asked about the memory usage of an algorithm. For this, the approach is to express the amount of memory required in terms of n, the size of the input, analogous to the preceding discussion of Big-O runtime analysis. The difference is that instead of determining how many operations are required for each item of input, you determine the amount of storage required for each item


Other times, you may be asked about the memory footprint of an implementation. This is usually an exercise in estimation, especially for languages such as Java and C# that run in a virtual machine. Interviewers don’t expect you to know to-the-byte exactly how much memory is used, but they like to see that you understand how the underlying data structures might be implemented.

SUMMARY

How you solve programming problems during your interviews can determine whether you get a job offer, so you need to answer them as correctly and completely as you can. The problems usually get progressively harder as the day progresses, so don’t be surprised if you need an occasional hint from the interviewer. You normally code in a mainstream programming language, but the choice of lan- guage is ultimately dictated by the requirements of the job for which you apply, so be familiar with the right languages.

Interact with your interviewers as much as possible as you attempt each problem. Let them know what you’re thinking at each point in your analysis of the problem and your attempts at coding an answer. Start by making sure you understand the problem, and then try some examples to reinforce that understanding. Choose the algorithm and make sure it works for those examples. Remember to test for special cases. If you’re stuck, try more examples or choose a different algorithm. Keep obscure or advanced language features in mind when looking for alternative answers.

If asked to comment on the performance of a solution, a Big-O runtime analysis is usually sufficient. Algorithms that run in constant, logarithmic, linear, or quasilinear time are preferred. You should also be prepared to comment on the memory footprint of an algorithm.


## Google Resume book

Passion. Creativity. Initiative. Intelligence. And a “getting things done” attitude. 

You need to be able to answer questions about your prior work with illustrative examples. You need to understand the company so that you can tell your interviewer why you want to work there and what you’ll add. And, finally, you need to be able to ask interesting questions to your interviewer that demonstrate your research and interest. 

Practice Your Pitch

* For each job or position, practice stating a short blurb explaining what your role was and what you accomplished. Practice two blurbs: one that would be understandable from those in your field, and one that’s understandable for nonspecialists. Stay light on the details and let the interview probe as necessary.

* Pay special attention to the pitches for your most recent role, as they’re the most relevant. You could even consider recording this pitch and playing it back to yourself—do you mumble during cer- tain parts? Friends can also be useful here. Where do they think you are weakest and strongest? 
behavior interview

prepare preparation grid.

put keyword

points :  challenging, what ou learned, influencing someone, conflict and mistake

![image](https://user-images.githubusercontent.com/25869911/163633510-c1c5eb97-0739-4ba2-a38b-007fbb26f7f4.png)

review your resume : 

The day before your interview, pick up your résumé and explain each bullet out loud, just as you would if your interviewer asks, “What did you mean by this line?” Make sure you can explain the “what, how, and why.” 


Do Your Homework

Recruiting is expensive, and companies want to know that you’re excited about the job. They hate having a candidate reject their offer almost as much as candidates hate getting rejected. Moreover, enthusiastic candidates are more likely to work hard at a job and stay at the company. Companies look for enthusiasm, and researching the company, position, and people is one way to prove that.


#### the programming interview

15 minutes - discussion, which usually includes some questions about your résumé and/or offers you a chance to ask the interviewer questions.
45 minutes - main coding interview

Google - bit manipulation and scalability like desing a web crawler

amazon - OO design questions, scalability questions .

microsoft - emphasize testing and design skills more in developers than other companies do

apple - Make sure you understand Apple’s products, especially those of the team you are interviewing with.  What would you improve about the product? Remember that Apple has a lot of smart people who haven’t yet done what you’re suggesting. Think about why they haven’t.

quality matters more than quantity 

* try to solve the problem on your own.
* write the code for the algorithm on paper
* test your code - manual
* type your code into a computer exactly as is - rerun what you written 
* start a list of all the mistakes you made, and analyze what types of mistakes you make the most ofter


Data structures

* Linked Lists, binary trees, tries, stacks, queues, vectors/arraylists, hash tables

Algorithms

* BFS, DFS, binary search, merge sort, quick sort, tree insert/find/etc

concepts

* bit manipulation, singleton desing pattern, factory design pattern, memory(stack vs heap), recursion, Big-o TIme

For each of the topics, make sure you understand how to implement/use them, and (where applicable) the space and time complexity.

We must often make a trade-off between time and space, and sometimes, we do sacrifice time efficiency to reduce memory usage.



1. Ask your interviewer questions to resolve ambiguity. 

* What are the data types? How much data is there? What assumptions do you need to solve the problem? Who is the user?

2. Design an algorithm. make example and see the pattern or general solution.

* What are the space and time complexities?
* What happens if there is a lot of data?
* Does your design cause other issues? (i.e., if you’re creating
a modified version of a binary search tree, did your design
impact the time for insert/find/delete?)
* If there are other issues, did you make the right trade-offs?
* If they gave you specific data (e.g., mentioned that the data is ages, or in sorted order), have you leveraged that informa- tion? There’s probably a reason that you’re given it.


3. Write pseudo-code first, but make sure to tell your interviewer that you’re writing pseudo-code! Otherwise, he/she may think that you’re never planning to write “real” code, and many interviewers will hold that against you.

* Writing pseudo-code first can help you outline your thoughts clearly and reduce the number of mistakes you commit.

4. Write your code, not too slow and not too fast.

* Use data structures generously. Where relevant, use a good data structure or define your own. For example, if you’re asked a problem involving finding the minimum age for a group of people, consider defining a data structure to represent a Person. This shows your interviewer that you care about good object-oriented design.

5. Test your code and carefully fix any mistakes.  -> normal test case and edge cases

* Extreme cases: 0, negative, null, maximums, etc.
* User error: What happens if the user passes in null or a nega-
tive value?
* General cases: Test the normal case.

6. tell big o of time and space

Algorithm Questions: Five Ways to Create an Algorithm

Keep in mind that the more problems you practice, the easier it will be to identify which approach to use.

Also, remember that the five approaches can be “mixed and matched.” That is, once you’ve applied “Simplify and Generalize,” you may want to implement Pattern Matching next.

Approach 1: Examplify

* Examplify simply means to write out specific examples of the problem and see if you can figure out a general rule.

Approach 2: Pattern Matching

Pattern matching means to relate a problem to similar ones, and figure out if you can modify the solution to solve the new problem. This is one reason why practicing lots of problems is important; the more problems you do, the better you get.

Approach 3: Simplify and Generalize

In Simplify and Generalize, we change constraints (data type, size, etc.) to simplify the problem, and then try to solve the simplified problem. Once you have an algorithm for the “simplified” problem, you can generalize the problem back to its original form

Approach 4: Base Case and Build

Base Case and Build suggests that we solve the algorithm first for a base case (e.g., just one element). Then, try to solve it for elements one and two, assuming that you have the answer for element one. Then, try to solve it for elements one, two, and three, assuming that you have the answer to elements one and two.


Approach 5: Data Structure Brainstorm

The Data Structure Brainstorm approach admittedly feels somewhat hacky, but it often works. In this approach, we simply run through a list of data structures and try to apply each one. This approach works because many algorithms are quite straightforward once we find the right data structure.

Object-oriented design (OOD) questions come in two flavors: OOD for a piece of software and OOD for a real-world object 

* What are your goals? Imagine, for example, you are asked to design the classes for a generic deck of cards. What kind of cards? Are they standard playing cards, UNO cards, or some other kind? Just how “generic” is it supposed to be? 
* What are the core objects? For example, if you’re doing the OOD for a restaurant, your core objects might be Restaurant, Patron, Party, Host, Server, Busser, Table, and so on. Each of these will become a class. 
* How do the objects relate to each other? There is probably only one Restaurant, so this can be a singleton class. Restaurant has many Servers, one Host, many Bussers, many Tables, many Parties, and many Patrons. (Note: This is just an assumption; talk to your interviewer about this). Each Table has one Server and one Party. Look for and remove redundancies. For example, Restaurant may not need a list of Patrons, since it can get that from the list of Parties. 
* How do the objects interact? Think about what the major actions that occur in the restaurant are. For example, a Party makes a Reservation with a Host. The Host sits the Party at a Table and assigns them a Server. Each of these actions should generally correspond to one or more meth- ods. By walking through these methods, you may discover that you missed some objects or that your design isn’t quite right. That’s OK—now is a great time to add them! 
* Are there any tricky algorithms? In some cases, there may be an algorithm that impacts the design. For example, implementing findNextReservation(int partySize) might require some changes to how the reservations are refer- enced. Discuss these details with your interviewer. 


Remember that object-oriented design questions require a lot of communication with your interviewer about how flexible your design should be and how to balance certain trade-offs. There is no “right” answer to an object-oriented design question.


Scalability Questions

When I interviewed at Google, I didn’t know a thing about large systems. Sure, I’d taken a distributed computing course where we studied election algorithms and whatnot, but that had nothing to do with what I was asked. Sort a million numbers? Design a web crawler? Yikes!

I fumbled my way through the problem, and I realized I could do this just fine. Once I forgot that I had no idea what I was doing, I learned that I actually understood the primary com- plexities of large amounts of data and dealing with multiple systems at once.
 
 All I needed to do was take things step by step. Imagine, for instance, that we’re designing a hypothetical system X for millions of items (users, files, etc.):
 
1. How would you solve the problem for a small number of items? Develop an algorithm for this case, which is often pretty straightforward.

2. What happens when you try to implement that algorithm with millions of items? It’s likely that you have run out of space on the computer. So, divide up the files across many computers.

* How do you divide up data across many machines? That is, do the first 100 items appear on the same computer? Or all items with the same hash value mod 100?
* About how many computers will you need? To esti- mate this, ask how big each item is, and take a guess at (or ask your interviewer) how much space a typical computer has.
 
 3. Now, fix the problems that occur when you are using many computers. Make sure to answer the following questions:

* How does one machine know which machine it should
access to look up data?
* Can data get out of sync across computers? How do you
handle that?
* How can you minimize expensive reads across computers?


testing interviews

True testing questions usually fall into one of three categories:

1. How would you test this real-world object?

steps:
* ask questions to understand what the object is
* Who is using it, and what are they doing with it?
* What are the unexpected uses?
* Are there additional stress cases?
* Can you fail gracefully?
* What are the test cases?


2. Explain how you would test this piece of computer software.

steps:
* Ask questions to resolve ambiguity.
* Who is the user?
* What is the feature set?
* Are there unexpected uses or stress cases?
* When there are failures, what can you do to fail gracefully?
* What can be automated, and what must be manu- ally tested?

3. Test a method (possibly one that you just wrote).

steps:
* As always, ask questions to resolve ambiguity
* What do you need to test for? 
* Write the expected cases.
* Write the extreme cases. 


## Grokking the coding interview

In many problems dealing with an array (or a LinkedList), we are asked to find or calculate something among all the subarrays (or sublists) of a given size. For example, take a look at this problem:

### Pattern: Sliding Window
#### Given an array, find the average of all subarrays of ‘K’ contiguous elements in it.

* Array: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5
* 
Here, we are asked to find the average of all subarrays of ‘5’ contiguous elements in the given array. Let’s solve this:

* For the first 5 numbers (subarray from index 0-4), the average is: (1+3+2+6-1)/5 => 2.2
(1+3+2+6−1)/5=>2.2
* The average of next 5 numbers (subarray from index 1-5) is: (3+2+6-1+4)/5 => 2.8
(3+2+6−1+4)/5=>2.8
* For the next 5 numbers (subarray from index 2-6), the average is: (2+6-1+4+1)/5 => 2.4
(2+6−1+4+1)/5=>2.4

Here is the final output containing the averages of all subarrays of size 5:

* Output: [2.2, 2.8, 2.4, 3.6, 2.8]

A brute-force algorithm will calculate the sum of every 5-element subarray of the given array and divide the sum by ‘5’ to find the average. This is what the algorithm will look like:

```java
import java.util.Arrays;

public class AverageOfSubarrayOfSizeK  {
    
    
    public static double[] findAverages(int k, int[] arr) {
        double[] result = new double[arr.length-k+1];
        
        for(int i =0; i <= arr.length - k; i++) {
            // find sum of next K elements
            double sum = 0;
            for(int j = i; j < i+k; j++) {
                sum+= arr[j];
            }
            result[i] = sum/k; // calculate average
        }
        
        return result;
        
    }
    
    public static void main(String args[]) {
        double[] result = AverageOfSubarrayOfSizeK.findAverages(5, new int[] {1,3,26,-1,4,1,8,2});
        System.out.println("Average of subarrays of size k: " + Arrays.toString(result));
    }
}
```
Time complexity: Since for every element of the input array, we are calculating the sum of its next ‘K’ elements, the time complexity of the above algorithm will be O(N*K) where ‘N’ is the number of elements in the input array.

input * K element -> 9 * 5 = 45

The inefficiency is that for any two consecutive subarrays of size ‘5’, the overlapping part (which will contain four elements) will be evaluated twice. For example, take the above-mentioned input:

![image](https://user-images.githubusercontent.com/25869911/163731416-c83364b1-c231-46fa-9c4d-1d281671621c.png)

As you can see, there are four overlapping elements between the subarray (indexed from 0-4) and the subarray (indexed from 1-5). Can we somehow reuse the sum we have calculated for the overlapping elements?

The efficient way to solve this problem would be to visualize each subarray as a sliding window of ‘5’ elements. This means that we will slide the window by one element when we move on to the next subarray. To reuse the sum from the previous subarray, we will subtract the element going out of the window and add the element now being included in the sliding window. This will save us from going through the whole subarray to find the sum and, as a result, the algorithm complexity will reduce to O(N).   

big(O)= 9

```java
import java.util.*;

public class AverageOfSubarrayOfSizeK {
    
    private static double[] getAverage(int K, int[] array) { 
        double[] result = new double[array.length-K+1]; //9-5+1 = 5
        
        double windSum = 0;
        int windStart = 0;
        
        for(int windEnd=0; windEnd < array.length; windEnd++) {  // 0 to 8 (size of 9)
            
            windSum += array[windEnd];
            
            if(windEnd >= K-1) { //5
                result[windStart] = windSum/K; // get the average
                windSum -= array[windStart]; // substract the lement going out
                windStart++; // slide the window ahead
            }
            
        }
        
        return result;
        
    }
    
    public static void main(String[] args) {
        int[] input = new int[]{1, 3, 2, 6, -1, 4, 1, 8, 2};
        double[] output = AverageOfSubarrayOfSizeK.getAverage(5,input);
        System.out.println("average of subarray of size k: "+ Arrays.toString(output));
        
    }
} 
```

#### Maximum Sum Subarray of Size K (easy)

Problem Statement

* Given an array of positive numbers and a positive number ‘k,’ find the maximum sum of any contiguous subarray of size ‘k’.

Example 1:

```terminal
Input: [2, 1, 5, 1, 3, 2], k=3 
Output: 9
Explanation: Subarray with maximum sum is [5, 1, 3].
```
Example 2:

```terminal
Input: [2, 3, 4, 1, 5], k=2 
Output: 7
Explanation: Subarray with maximum sum is [3, 4].
```

Solution

A basic brute force solution will be to calculate the sum of all ‘k’ sized subarrays of the given array to find the subarray with the highest sum. We can start from every index of the given array and add the next ‘k’ elements to find the subarray’s sum. Following is the visual representation of this algorithm for Example-1:

![image](https://user-images.githubusercontent.com/25869911/163733398-e3a9ed9c-d865-4ec8-a0e5-69d424268feb.png)

brute force solution

```java
public static int findMaxSumSubArray(int k, int[] arr) {
   int maxSum = 0, windowSum;
   for (int i = 0; i <= arr.length - k; i++) {
     windowSum = 0;
     for (int j = i; j < i + k; j++) {
       windowSum += arr[j];
     }
     maxSum = Math.max(maxSum, windowSum);
   }

   return maxSum;
 }

 public static void main(String[] args) {
   System.out.println("Maximum sum of a subarray of size K: "
       + MaxSumSubArrayOfSizeK.findMaxSumSubArray(3, new int[] { 2, 1, 5, 1, 3, 2 }));
   System.out.println("Maximum sum of a subarray of size K: "
       + MaxSumSubArrayOfSizeK.findMaxSumSubArray(2, new int[] { 2, 3, 4, 1, 5 }));
 }
 ```
 The above algorithm’s time complexity will be O(N*K), where ‘N’ is the total number of elements in the given array.
 
If you observe closely, you will realize that to calculate the sum of a contiguous subarray, we can utilize the sum of the previous subarray. For this, consider each subarray as a Sliding Window of size ‘k.’ To calculate the sum of the next subarray, we need to slide the window ahead by one element. So to slide the window forward and calculate the sum of the new position of the sliding window, we need to do two things:

* Subtract the element going out of the sliding window, i.e., subtract the first element of the window.
* Add the new element getting included in the sliding window, i.e., the element coming right after the end of the window.

Solution
```java
class MaxSumSubArrayOfSizeK {
  public static int findMaxSumSubArray(int k, int[] arr) {
    int max = 0;
    int sum = 0;
    int result[] = new int[arr.length-k+1]; //4
    int sumWindow = 0;
    int startWindow = 0;

    for(int endWindow = 0; endWindow < arr.length; endWindow++) {
      sum += arr[endWindow];

      if(endWindow >= k-1) {
        max = Math.max(max,sum) // max = (max < sum) ? sum: max;
        sum -= arr[startWindow]; 
        startWindow++;
      }
    }

    return max;
  }
}
```



Time Complexity

The time complexity of the above algorithm will be O(N)

Space Complexity

The algorithm runs in constant space O(1)

#### Smallest Subarray With a Greater Sum (easy)


Given an array of positive numbers and a positive number ‘S,’ find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’. Return 0 if no such subarray exists.

Example 1:

```terminal
Input: [2, 1, 5, 2, 3, 2], S=7
Output: 2
Explanation: The smallest subarray with a sum greater than or equal to ‘7’ is [5, 2].
```
Example 2:
```terminal
Input: [2, 1, 5, 2, 8], S=7
Output: 1
Explanation: The smallest subarray with a sum greater than or equal to ‘7’ is [8].
```
```terminal
Example 3:

Input: [3, 4, 1, 1, 6], S=8
Output: 3
Explanation: Smallest subarrays with a sum greater than or equal to ‘8’ are [3, 4, 1] or [1, 1, 6].
```

Solution

This problem follows the Sliding Window pattern, and we can use a similar strategy as discussed in Maximum Sum Subarray of Size K. There is one difference though: in this problem, the sliding window size is not fixed. Here is how we will solve this problem:

* First, we will add-up elements from the beginning of the array until their sum becomes greater than or equal to ‘S.’
* These elements will constitute our sliding window. We are asked to find the smallest such window having a sum greater than or equal to ‘S.’ We will remember the length of this window as the smallest window so far.
* After this, we will keep adding one element in the sliding window (i.e., slide the window ahead) in a stepwise fashion.
* In each step, we will also try to shrink the window from the beginning. We will shrink the window until the window’s sum is smaller than ‘S’ again. This is needed as we intend to find the smallest window. This shrinking will also happen in multiple steps; in each step, we will do two things:
  * Check if the current window length is the smallest so far, and if so, remember its length.
  * Subtract the first element of the window from the running sum to shrink the sliding window.

Here is the visual representation of this algorithm for the Example-1:

![image](https://user-images.githubusercontent.com/25869911/163734481-cc908024-9024-405c-ada0-e71e3935e56a.png)

![image](https://user-images.githubusercontent.com/25869911/163734489-a15e091e-2205-4ec7-83ed-03d62d82bfd3.png)

```java
public static int findMinSubArray(int S, int[] arr) {
   int windowSum = 0, minLength = Integer.MAX_VALUE;
   int windowStart = 0;
   for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {
     windowSum += arr[windowEnd]; // add the next element
     // shrink the window as small as possible until the 'windowSum' is smaller than 'S'
     while (windowSum >= S) {
       minLength = Math.min(minLength, windowEnd - windowStart + 1);
       windowSum -= arr[windowStart]; // subtract the element going out
       windowStart++; // slide the window ahead
     }
   }

   return minLength == Integer.MAX_VALUE ? 0 : minLength;
 }
```
Time Complexity

The time complexity of the above algorithm will be O(N). The outer for loop runs for all elements, and the inner while loop processes each element only once; therefore, the time complexity of the algorithm will be O(N+N), which is asymptotically equivalent to O(N)


Space Complexity

The algorithm runs in constant space O(1)

### Pattern: Two Pointers

In problems where we deal with sorted arrays (or LinkedLists) and need to find a set of elements that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem:


* Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.

To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where ‘N’ is the number of elements in the input array.

Given that the input array is sorted, an efficient way would be to start with one pointer in the beginning and another pointer at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do not, we will do one of two things:

* If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.

* If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.

![image](https://user-images.githubusercontent.com/25869911/164612377-3b0aa808-341b-475b-81eb-8aaf6b0e217f.png)

The time complexity of the above algorithm will be O(N)

In the following chapters, we will apply the Two Pointers approach to solve a few problems.


#### Pair with Target Sum (easy)

Problem Statement

Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.

Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.

Example 1:
```terminal
Input: [1, 2, 3, 4, 6], target=6
Output: [1, 3]
Explanation: The numbers at index 1 and 3 add up to 6: 2+4=6
Example 2:
```
```terminal
Input: [2, 5, 9, 11], target=11
Output: [0, 2]
Explanation: The numbers at index 0 and 2 add up to 11: 2+9=11
```

##### Solution brute force

To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where ‘N’ is the number of elements in the input array.

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {
    // TODO: Write your code here
    int[] result = new int[2];
    for(int i=0; i < arr.length; i++) {
      for(int j=i+1; j < arr.length; j++) {
        if(arr[i]+arr[j] == targetSum) {
          result[0] = i;
          result[1] = j;
        }
      }
    }
    return result;
  }
}
```

##### Solution two pointers

Since the given array is sorted, a brute-force solution could be to iterate through the array, taking one number at a time and searching for the second number through Binary Search. The time complexity of this algorithm will be O(N*logN). Can we do better than this?

We can follow the Two Pointers approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair; otherwise, we will do one of two things:

* If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.
* If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.

![image](https://user-images.githubusercontent.com/25869911/164617047-9a815b96-a397-40d8-beab-9ec920f79e08.png)

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {
    
    // left and right pointer
    int leftPointer = 0, rightPointer = arr.length-1;
    
    while(leftPointer < rightPointer) {
      int currentSum = arr[leftPointer]+arr[rightPointer];
      // found the pair 
      if(currentSum == targetSum) {
        return new int[]{leftPointer, rightPointer}; 
      }

      if(currentSum < targetSum) {
        leftPointer++;
      } else {
        rightPointer--;
      }
    }
    
    return new int[] {-1,-1};
  }
}
```
Time Complexity
The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array.

Space Complexity

The algorithm runs in constant space O(1)

##### An Alternate approach

Instead of using a two-pointer or a binary search approach, we can utilize a HashTable to search for the required pair. We can iterate through the array one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ such that “X + Y == Target”. We will do two things here:

* Search for ‘Y’ (which is equivalent to “Target - X”) in the HashTable. If it is there, we have found the required pair.
* Otherwise, insert “X” in the HashTable, so that we can search it for the later numbers.

Here is what our algorithm will look like:

```java
class PairWithTargetSum {

  public static int[] search(int[] arr, int targetSum) {

    HashMap<Integer, Integer> numbers = new HashMap<Integer,Integer>();

    for(int i = 0; i < arr.length; i++) {
      if(numbers.containsKey(targetSum-arr[i])) {
        return new int[] { numbers.get(targetSum-arr[i]), i };
      } else {
        numbers.put(arr[i], i);
      }
    }

    return new int[]{-1,-1};
  
  }
}
```

Time Complexity
The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array.

Space Complexity
The space complexity will also be O(N), as, in the worst case, we will be pushing ‘N’ numbers in the HashTable.

* Solutions :

worst = iterate all element with 2 fors time complexity(n^2)->quadratic and space complexity(1)
average = iterate n first element and second element use binary search (n * log n) and space complexity(1)
improved = hash table time (n) but also space is (n)
best = two pointers time(n)-> lineal but space is (1) ->constant


### Pattern: Fast & Slow pointers

The Fast & Slow pointer approach, also known as the Hare & Tortoise algorithm, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic(circulary) LinkedLists or arrays.

By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop.

One of the famous problems solved using this technique was Finding a cycle in a LinkedList. Let’s jump onto this problem to understand the Fast & Slow pattern.

#### LinkedList Cycle (easy)

Problem Statement

Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

![image](https://user-images.githubusercontent.com/25869911/164634074-3b64cf3a-2af3-49e6-85e1-dfcece0a23ad.png)

* Solution

Imagine two racers running in a circular racing track. If one racer is faster than the other, the faster racer is bound to catch up and cross the slower racer from behind. We can use this fact to devise an algorithm to determine if a LinkedList has a cycle in it or not.

Imagine we have a slow and a fast pointer to traverse the LinkedList. In each iteration, the slow pointer moves one step and the fast pointer moves two steps. This gives us two conclusions:

* If the LinkedList doesn’t have a cycle in it, the fast pointer will reach the end of the LinkedList before the slow pointer to reveal that there is no cycle in the LinkedList.
* The slow pointer will never be able to catch up to the fast pointer if there is no cycle in the LinkedList.

If the LinkedList has a cycle, the fast pointer enters the cycle first, followed by the slow pointer. After this, both pointers will keep moving in the cycle infinitely. If at any stage both of these pointers meet, we can conclude that the LinkedList has a cycle in it. Let’s analyze if it is possible for the two pointers to meet. When the fast pointer is approaching the slow pointer from behind we have two possibilities:

* The fast pointer is one step behind the slow pointer.
* The fast pointer is two steps behind the slow pointer.

All other distances between the fast and slow pointers will reduce to one of these two possibilities. Let’s analyze these scenarios, considering the fast pointer always moves first:

* If the fast pointer is one step behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step, and they both meet.
* If the fast pointer is two steps behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step. After the moves, the fast pointer will be one step behind the slow pointer, which reduces this scenario to the first scenario. This means that the two pointers will meet in the next iteration.

This concludes that the two pointers will definitely meet if the LinkedList has a cycle. A similar analysis can be done where the slow pointer moves first. Here is a visual representation of the above discussion:

![image](https://user-images.githubusercontent.com/25869911/164648164-3097975e-f573-46f5-bd52-ce59214559dc.png)

https://github.com/lastguemamusa01/LeetCode-Exercises/tree/main/141-linked-list-cycle

 ```java
 class ListNode {
  int value = 0;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class LinkedListCycle {

  public static boolean hasCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
      if(fast == slow) return true;
    }
    return false;
  }

  public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    head.next.next.next.next.next = new ListNode(6);
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));

    head.next.next.next.next.next.next = head.next.next;
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));

    head.next.next.next.next.next.next = head.next.next.next;
    System.out.println("LinkedList has cycle: " + LinkedListCycle.hasCycle(head));
  }
}
```

Time Complexity

As we have concluded above, once the slow pointer enters the cycle, the fast pointer will meet the slow pointer in the same loop. Therefore, the time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList.

Space Complexity

The algorithm runs in constant space O(1)

#### Similar Problems

* Problem 1: Given the head of a LinkedList with a cycle, find the length of the cycle.

* Solution: We can use the above solution to find the cycle in the LinkedList. Once the fast and slow pointers meet, we can save the slow pointer and iterate the whole cycle with another pointer until we see the slow pointer again to find the length of the cycle.

Here is what our algorithm will look like:

```java
class ListNode {
  int value = 0;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class LinkedListCycleLength {

  public static int findCycleLength(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
      if (slow == fast) // found the cycle
        return calculateLength(slow);
    }
    return 0;
  }

  private static int calculateLength(ListNode slow) {
    ListNode current = slow;
    int cycleLength = 0;
    do {
      current = current.next;
      cycleLength++;
    } while (current != slow);
    return cycleLength;
  }

  public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    head.next.next.next.next.next = new ListNode(6);
    head.next.next.next.next.next.next = head.next.next;
    System.out.println("LinkedList cycle length: " + LinkedListCycleLength.findCycleLength(head));

    head.next.next.next.next.next.next = head.next.next.next;
    System.out.println("LinkedList cycle length: " + LinkedListCycleLength.findCycleLength(head));
  }
}
```


Time and Space Complexity: The above algorithm runs in O(N) time complexity and O(1) space complexity.

### Pattern: Merge Intervals

This pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap.

Given two intervals (‘a’ and ‘b’), there will be six different ways the two intervals can relate to each other:

![image](https://user-images.githubusercontent.com/25869911/164877773-47e52ca4-06e1-4c4f-bb1c-dc3923a9c5da.png)




