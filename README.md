# interview-study
interview study materials 101


## Interview exposed book

1 - bofre the search

find what kind of programmer your are(what do you like to do)

application dev

short-term projects


Visit two kinds of job sites as part of your research. Job listing sites such as Dice (which specializes in technology-related career listings), Indeed, and Monster (general job listing sites) enable you to see what kinds of jobs are currently in demand. Review sites such as Glassdoor discuss working conditions, salaries, bonuses, perks, and other informa- tion useful for finding the right kind of company for you.

No contracts and no offshore


Another way to make yourself more difficult to replace is to acquire domain specific knowledge: expertise related to the programs you write but outside of the field of programming. For example, if you develop financial software, it’s much more difficult to out- source your job if it involves the application of accounting skills in addition to programming than if you’re purely a coder.

develop marketable skills

* participating in programming contests
* proffeesional development courses - coursera, etc
* master or doctorate degree
* don't bother with certifications
* work on side project , or open source development
* Use code contest sites. TopCoder, HackerRank, CodeWars, and several similar sites have developers “face-off” to solve programming problems. If you win, meaning you solve the problem faster than the competitor or bot, you move up the leaderboards and get a higher rank, which you can make public and list on your résumé.

Companies look for software developers who get things done. You may look great on paper in terms of skills and education, but credentials and knowledge don’t make products or services that a company can sell. It’s your ability to accomplish something that truly sets you apart from the other candidates.

Your online profile—everything public about you online—is just as important as your résumé. Recruiters use online profiles to find desirable candidates

* Google search results for your name. This is the first impression you make on potential employers and colleagues.
* LinkedIn profile. LinkedIn is a social network for tracking professional connections. It’s free to join, and you can create a detailed profile about yourself, including your jobs and your education—essentially an online résumé. Colleagues and customers can publicly endorse you or your work, which can be quite valuable.
* GitHub profile. Many employers will evaluate your work through your GitHub profile well before they meet you. Take a look and spend a few hours to clean up your GitHub profile so it reflects your best code. Delete or change the privacy settings for incomplete, poorly orga- nized, or low-quality repositories. Assume your profile may be checked even before you’re asked about it. If you don’t have very much public, move your best code to public so it’s clear that you have significant code and experience with GitHub.
* Stack Overflow. This will show up on your Google search result, or may be checked. If you have recent, basic questions that reflect poorly on your knowledge, you may want to delete them. If you don’t have a profile, you should make one, especially if your job search is still a few months out and you have time to answer other people’s questions.
* Angel investor sites. These sites don’t just connect investors with startups, they also connect startups with potential hires. AngelList is the big player in this category. Create a profile that reflects your interests and expertise.
* Other social network profiles. Other social networks such as Facebook, Twitter, or Snapchat may be reviewed, depending on your privacy settings. Make sure you clean up and tighten your profile so nothing unprofessional appears public.
* Personal website. This is a potential source of more in-depth information about you and top- ics you find interesting. If you blog about political or controversial topics, you may want to remove such posts during your job search.
* Articles and blog posts. If you write about programming-related topics, this is a good way for recruiters to assess your experience.
* Comments and forum posts. These provide another way to gain some insight into your pro- gramming skills and your general attitude toward technology and technology companies.


WARNING One caveat about updating your LinkedIn profile: by default, all your contacts are notified of your updates. Many people have learned to inter- pret these notifications as de facto announcements that someone is looking for a new job. That might help you get the word out, but if your contacts include people at your current company and you don’t want them to know you’re look- ing for a new job, disable these notifications before you make your updates.

What you do before a formal job search is critical to finding the right kind of job. With that in mind, you should consider the following things:

* Know your likes and dislikes as a programmer and a prospective employee.
* Understand the market to find and apply for the best jobs.
* Develop the marketable skills that employers look for and that can enhance your career.
* Manage your public profile to show you in the best possible light and make sure there are no surprises to turn off potential employers.


## 2 - the job application process


Interviewing and recruiting procedures are similar at most tech companies, so the more pre- pared you are for what you will encounter, the more successful you will be. This chapter familiarizes you with the entire job-search process, from contacting companies to starting your new job, so you won’t need to write off your first few application attempts as learning experiences.

FINDING AND CONTACTING COMPANIES

The first step to getting a job is to find and make contact with companies you’re interested in working for. Although referrals are the best way to land a job, you can also work with head- hunters or contact a company directly.


* decide the companies that you are going to apply
* add the all known people in facebook or linked in who working that company that you want to work
* top coder, hackerrank and codewars.
* applied in the offitial page -> headhunter or referrals


After you’ve been given a specific offer that includes details about salary, signing bonus, benefits, and possibly stock options, you need to decide whether you’re satisfied with it. This shouldn’t be a snap decision—never accept an offer on the spot. Always spend at least a day thinking about impor- tant decisions such as this; it’s surprising how much can change in a day.


Negotiating Your Salary

If, after careful consideration, the offer meets or exceeds your expectations, you’re all set. On the other hand, if you’re not completely happy with your offer, you should try to negotiate. Most people ask for too little, as opposed to too much. Don’t be afraid to “lean in,” no matter who you are or

what your background is. All too often, applicants assume that offers are nonnegotiable and reject them without negotiation or accept offers they’re not pleased with. Almost every offer is negotiable to some extent.


You can find prospective jobs in various ways, but networking through friends and acquaintances is usually the best method. If that’s not possible, find and contact companies directly. You may also engage the services of a headhunter; be aware that the headhunter’s motivations aren’t always aligned with yours.
The interviews are the most important part of the job application process. You will have one or two screening interviews, usually by phone, to ensure that you’re applying for the right job and that you are actually qualified. After the screening interviews, you’ll usually go through a series of on-site technical interviews that ultimately determine whether a job offer comes your way. Be sure to dress appropriately for the interviews, and turn off any electronic gadgets you might have with you.
During the interview process you’ll frequently interact with one of the company’s recruiters, espe- cially if a job offer is made. Be sure to understand the recruiter’s role during this process.
When an offer is made, don’t accept it immediately. Give yourself time to consider it. Look over the offer, and try to negotiate a better deal because most offers aren’t fixed in stone, no matter what the recruiter says. After accepting a job offer, be sure to contact anyone else who has made you an offer to thank them for their interest in you.

phone screen interview(1st interview)

Knowledge-based questions are common during on-site interviews as well as phone screens -> from you resume one or two

some basic coding and design tasks.


Instead, many of these problems require algorithmic tricks or uncommonly used features of a language.

The problems often prohibit you from using the most common way to do something or from using the ideal data structure. For example, you might be given a problem such as: “Write a function that determines whether two integers are equal without using any comparison operators.”

Interactivity Is Key
The code you write in the interview is probably the only example of your code that your interviewer sees. If you write ugly code, your interviewer will assume you always write ugly code. This is your chance to shine and show your best code. Take the time to make your code solid and pretty.


What the interviewer wants is to see your thought processes as you work through each stage of the programming problem.

The problem-solving process in these interviews is interactive, and if you have difficulty, the inter- viewer generally guides you to the correct answer via a series of hints. Of course, the less help you need to solve the problem, the better you look, but showing an intelligent thought process and responding well to the hints you are given is also important. 

 Break down the answer into discrete steps and explain the thought processes behind each step.
 
 Keep talking! Always explain what you are doing. Otherwise, the inter- viewer has no way of knowing how you tackle complex programming problems.
 
When you begin solving a problem, don’t start writing code immediately. First, make sure you com- pletely understand the problem. It may help to work through a simple, concrete example and then try to generalize the process to an algorithm. When you’re convinced you have the right algorithm, explain it clearly. Writing the code should be one of your final steps.
 

1 - Make sure you understand the problem. Your initial assumptions about the problem may be wrong, or the interviewer’s explanation may be brief or difficult to follow. You can’t demon- strate your skills if you don’t understand the problem. Don’t hesitate to ask your interviewer questions, and don’t start solving the problem until you understand it. The interviewer may be deliberately obscuring things to determine whether you can find and understand the actual problem. In these cases, asking the right clarifying questions is an important part of the cor- rect solution.

2 - When you understand the question, try a simple example. This example may lead to insights about how to solve the general problem or bring to light any remaining misunderstandings that you have. Starting with an example also demonstrates a methodical, logical thought process. Examples are especially useful if you don’t see the solution right away.

3 - Focus on the algorithm and data structures you will use to solve the problem. This can take a long time and require additional examples. This is to be expected. Interactivity is important during this process. If you stand quietly staring at the whiteboard, the interviewer has no way of knowing whether you’re making productive headway or are simply clueless. Talk to your interviewer about what you are doing. For example, you might say something like, “I’m wondering whether I can store the values in an array and then sort them, but I don’t think that will work because I can’t quickly look up elements in an array by value.” This demon- strates your skill, which is the point of the interview, and may also lead to hints from the interviewer, who might respond, “You’re close to the solution. Do you really need to look up elements by value, or could you....”

It may take a long time to solve the problem, and you may be tempted to begin coding before you figure out a complete solution. Resist this temptation. Consider who you would rather work with: someone who thinks about a problem for a long time and then codes it correctly the first time or someone who hastily jumps into a problem, makes several errors while cod- ing, and doesn’t have any idea what direction to take. Not a difficult decision, is it?

4 - After you figure out your algorithm and how you can implement it, explain your solution
to the interviewer. This provides an opportunity to evaluate your solution before you begin coding. Your interviewer may say, “Sounds great, go ahead and code it,” or something
like, “That’s not quite right because you can’t look up elements in a hash table that way.” Another common response is “That sounds like it will work, but there’s a more efficient solu- tion.” In any case, you gain valuable information about whether you should move on to cod- ing or go back to working on the algorithm.

5 - While you code, explain what you’re doing. For example, you might say, “Here, I’m initial- izing the array to all zeros.” This narrative enables the interviewer to follow your code more easily.


6- Ask questions when necessary. You generally won’t be penalized for asking factual questions that you might otherwise look up in a reference. You obviously can’t ask a question such
as, “How do I solve this problem?” but it is acceptable to ask a question such as, “I can’t remember—what format string do I use to print out a localized date?” Although it’s better to know these things, it’s okay to ask this sort of question.

7- After you write the code for a problem, immediately verify that the code works by tracing through it with an example. This step demonstrates clearly that your code is correct in at least one case. It also illustrates a logical thought process and your intention to check your work and search for bugs. The example may also help you flush out minor bugs in your solution.

8- Make sure you check your code for all error and special cases, especially boundary condi- tions. Programmers often overlook error and special cases; forgetting these cases in an interview indicates you might forget them on the job. If time does not allow for extensive checking, at least explain that you should check for such failures. Covering error and special cases can impress your interviewer and help you correctly solve the problem.

After you try an example and feel comfortable that your code is correct, the interviewer may ask you questions about what you wrote. These questions often focus on running time, alternative implementations, and complexity (discussed later in this chapter). If your interviewer does not ask you these questions, you should volunteer the information to show that you are cognizant of these issues. For example, you could say, “This implementation has linear running time, which is the best achievable running time since I need to check all the input values. The dynamic memory allocation will slow it down a little, as will the overhead of using recursion.”

When You Get Stuck

Getting stuck on a problem is expected and an important part of the interviewing process. Interviewers want to see how you respond when you don’t recognize the answer to a question imme- diately. Giving up or getting frustrated is the worst thing to do if this happens to you. Instead, show interest in the problem and keep trying different ways to solve it:

* Go back to an example. Try performing the task and analyzing what you are doing. Try extending your specific example to the general case. You may have to use detailed examples. This is okay, because it shows the interviewer your persistence in finding the correct solution.

* Try a different data structure. Perhaps a linked list, an array, a hash table, or a binary search tree can help. If you’re given an unusual data structure, look for similarities between it and more familiar data structures. Using the right data structure often makes a problem much easier.

* Consider the less commonly used or more advanced aspects of a language. Sometimes the key to a problem involves one of these features.


Even when you don’t feel stuck, you may not be converging on the optimal solution. You may miss an elegant or nonobvious way to implement something. Pause every once in a while to reconsider the bigger picture and whether there may be a better approach. One sign that you may be off track is if you find yourself writing too much code. Almost all interview coding questions have short answers. You rarely need to write more than 30 lines of code and almost never more than 50. If you start writing a lot of code, you may be heading in the wrong direction.

### ANALYZING YOUR SOLUTION

After you answer the problem, you may be asked about the efficiency of your implementation. Often, you have to compare trade-offs between your implementation and another possible solution and identify the conditions that make each option more favorable. Common questions focus on run time and memory usage.

A good understanding of Big-O analysis is critical to making a good impression with the inter- viewer. Big-O analysis is a form of runtime analysis that measures the efficiency of an algorithm in terms of the time it takes for the algorithm to run as a function of the input size. It’s not a formal benchmark, just a simple way to classify algorithms by relative efficiency when dealing with very large input sizes.
Most coding problem solutions in this book include a runtime analysis to help you solidify your understanding of the algorithms.


Best, Average, and Worst Cases
You may think this comparison was stacked against CompareToAll because the maximum value was at the end. This is true, and it raises the important issues of best-case, average-case, and worst-case running times. The analysis of CompareToAll was a worst-case scenario: the maximum value was at the end of the array. Consider the average case, in which the largest value is in the middle. You end up checking only half the values n times because the maximum value is in the middle. This results
in checking n(n/2) = n2/2 times. This would appear to be an O(n2/2) running time. However, Big-O analysis is concerned with the way the running time changes as the input becomes very large. As n increases toward infinity, the difference between n2/2 and n2 become negligible relative to the differ- ence between n2 and any other functional form (e.g., n or n3). Therefore, in Big-O analysis, you drop all constant factors, just as you drop all lower order terms. This is why you can consider the time
for every operation to be equivalent: considering different constant time requirements for different operations would yield a constant multiplicative factor, which you would drop anyway. With this in mind, the average case for CompareToAll is no better than the worst case. It is still O(n2).

The best-case running time for CompareToAll is better than O(n2). In this case, the maximum value is at the beginning of the array. The maximum value is compared to all other values only once, so the result is an O(n) running time.

In CompareToMax, the best-case, average-case, and worst-case running times are identical. Regardless of the arrangement of the values in the array, the algorithm is always O(n).

Ask interviewers which scenario they’re most interested in. Sometimes you’ll find clues to this in the problem. Some sorting algorithms with terrible worst cases for unsorted data may nonetheless be well suited for a problem if the input is already sorted. These kinds of trade-offs are discussed in

The fastest possible running time for any runtime analysis is O(1), commonly referred to as con- stant running time. An algorithm with constant running time always takes the same amount of time to execute, regardless of the input size. This is the ideal run time for an algorithm, but it’s rarely achievable.

* O(log n). An algorithm is said to be logarithmic if its running time increases logarithmically in proportion to the input size.
log 10 = 1

* O(n). A linear algorithm’s running time increases in direct proportion to the input size.
10 = 10

* O(n log n). A quasilinear algorithm is midway between a linear algorithm and a polynomial
algorithm.
10 log 10 = 10 

* O(n^c). A polynomial algorithm grows quickly based on the size of the input.
10^2 = 100

* O(c^n). An exponential algorithm grows even faster than a polynomial algorithm.
2^10= 1,024

* O(n!). A factorial algorithm grows the fastest and becomes quickly unusable for even small
values of n.
10! = 3,628,800

Memory Footprint Analysis

Runtime analysis is not the only relevant metric for performance. A common request from inter- viewers is to analyze how much memory a program uses. This is sometimes referred to as the memory footprint of the application. Memory use is sometimes as important as running time, par- ticularly in constrained environments such as embedded systems.

In some cases, you will be asked about the memory usage of an algorithm. For this, the approach is to express the amount of memory required in terms of n, the size of the input, analogous to the preceding discussion of Big-O runtime analysis. The difference is that instead of determining how many operations are required for each item of input, you determine the amount of storage required for each item


Other times, you may be asked about the memory footprint of an implementation. This is usually an exercise in estimation, especially for languages such as Java and C# that run in a virtual machine. Interviewers don’t expect you to know to-the-byte exactly how much memory is used, but they like to see that you understand how the underlying data structures might be implemented.

SUMMARY

How you solve programming problems during your interviews can determine whether you get a job offer, so you need to answer them as correctly and completely as you can. The problems usually get progressively harder as the day progresses, so don’t be surprised if you need an occasional hint from the interviewer. You normally code in a mainstream programming language, but the choice of lan- guage is ultimately dictated by the requirements of the job for which you apply, so be familiar with the right languages.

Interact with your interviewers as much as possible as you attempt each problem. Let them know what you’re thinking at each point in your analysis of the problem and your attempts at coding an answer. Start by making sure you understand the problem, and then try some examples to reinforce that understanding. Choose the algorithm and make sure it works for those examples. Remember to test for special cases. If you’re stuck, try more examples or choose a different algorithm. Keep obscure or advanced language features in mind when looking for alternative answers.

If asked to comment on the performance of a solution, a Big-O runtime analysis is usually sufficient. Algorithms that run in constant, logarithmic, linear, or quasilinear time are preferred. You should also be prepared to comment on the memory footprint of an algorithm.
